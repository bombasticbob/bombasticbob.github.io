<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>X11workbench Toolkit: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">X11workbench Toolkit
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__platform__functions.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__platform.html">Platform Independence</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadc42f83070453daa04ccf39dc842d93b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__types.html#gafe03a6c44f6d9df7e0e4bf1e8f49967a">WB_UINT64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__functions.html#gadc42f83070453daa04ccf39dc842d93b">WBGetTimeIndex</a> (void)</td></tr>
<tr class="memdesc:gadc42f83070453daa04ccf39dc842d93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current 'time index' (in microseconds)  <a href="#gadc42f83070453daa04ccf39dc842d93b">More...</a><br /></td></tr>
<tr class="separator:gadc42f83070453daa04ccf39dc842d93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94004281108be87acc4fb37deef0a104"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__functions.html#ga94004281108be87acc4fb37deef0a104">WBDelay</a> (uint32_t uiDelay)</td></tr>
<tr class="memdesc:ga94004281108be87acc4fb37deef0a104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay for a specified period in microseconds.  <a href="#ga94004281108be87acc4fb37deef0a104">More...</a><br /></td></tr>
<tr class="separator:ga94004281108be87acc4fb37deef0a104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fcd397013eb85afa4077ef76849a05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__functions.html#ga24fcd397013eb85afa4077ef76849a05">WBCPUCount</a> (void)</td></tr>
<tr class="memdesc:ga24fcd397013eb85afa4077ef76849a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of available CPU cores.  <a href="#ga24fcd397013eb85afa4077ef76849a05">More...</a><br /></td></tr>
<tr class="separator:ga24fcd397013eb85afa4077ef76849a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa2be84e6aa35494ef5c78db3fe19886"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__functions.html#gaaa2be84e6aa35494ef5c78db3fe19886">my_qsort_r</a> (void *base, int nmemb, int size, void *thunk, int(*compar)(void *, const void *, const void *))</td></tr>
<tr class="memdesc:gaaa2be84e6aa35494ef5c78db3fe19886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local implementation of qsort_r() for operating systems that do not have it.  <a href="#gaaa2be84e6aa35494ef5c78db3fe19886">More...</a><br /></td></tr>
<tr class="separator:gaaa2be84e6aa35494ef5c78db3fe19886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ffb9b6c8c93ea9e20706c62b4b7713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__types.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__functions.html#ga99ffb9b6c8c93ea9e20706c62b4b7713">WBCreatePointerHash</a> (void *pPointer)</td></tr>
<tr class="memdesc:ga99ffb9b6c8c93ea9e20706c62b4b7713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create/obtain a 32-bit 'secure' hash for a pointer.  <a href="#ga99ffb9b6c8c93ea9e20706c62b4b7713">More...</a><br /></td></tr>
<tr class="separator:ga99ffb9b6c8c93ea9e20706c62b4b7713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966312c55d70aba382f3a9b714c024e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__functions.html#ga966312c55d70aba382f3a9b714c024e2">WBDestroyPointerHash</a> (<a class="el" href="group__platform__types.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a> uiHash)</td></tr>
<tr class="memdesc:ga966312c55d70aba382f3a9b714c024e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a 32-bit 'secure' hash for a pointer.  <a href="#ga966312c55d70aba382f3a9b714c024e2">More...</a><br /></td></tr>
<tr class="separator:ga966312c55d70aba382f3a9b714c024e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c295f7a7fb34ed8f99a6abaa598b8a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__functions.html#ga9c295f7a7fb34ed8f99a6abaa598b8a8">WBDestroyPointerHashPtr</a> (void *pPointer)</td></tr>
<tr class="memdesc:ga9c295f7a7fb34ed8f99a6abaa598b8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a 32-bit 'secure' hash for a pointer regardless of reference count.  <a href="#ga9c295f7a7fb34ed8f99a6abaa598b8a8">More...</a><br /></td></tr>
<tr class="separator:ga9c295f7a7fb34ed8f99a6abaa598b8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5193bbf0de01aa9cb4c1d3ea8923448"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__functions.html#gab5193bbf0de01aa9cb4c1d3ea8923448">WBGetPointerFromHash</a> (<a class="el" href="group__platform__types.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a> uiHash)</td></tr>
<tr class="memdesc:gab5193bbf0de01aa9cb4c1d3ea8923448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a pointer from a 32-bit 'secure' pointer hash value.  <a href="#gab5193bbf0de01aa9cb4c1d3ea8923448">More...</a><br /></td></tr>
<tr class="separator:gab5193bbf0de01aa9cb4c1d3ea8923448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ed97b8fd7aedff5948c1800fa59455"><td class="memItemLeft" align="right" valign="top">Atom&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__functions.html#gaf3ed97b8fd7aedff5948c1800fa59455">WBGetAtom</a> (Display *pDisplay, const char *szAtomName)</td></tr>
<tr class="memdesc:gaf3ed97b8fd7aedff5948c1800fa59455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and/or allocate an internal Atom for a named string (lookups include X11 atoms)  <a href="#gaf3ed97b8fd7aedff5948c1800fa59455">More...</a><br /></td></tr>
<tr class="separator:gaf3ed97b8fd7aedff5948c1800fa59455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9521326551eb30d23685ab9e4622666"><td class="memItemLeft" align="right" valign="top">Atom&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__functions.html#gab9521326551eb30d23685ab9e4622666">WBLookupAtom</a> (Display *pDisplay, const char *szAtomName)</td></tr>
<tr class="memdesc:gab9521326551eb30d23685ab9e4622666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup (but do not allocate) an internal (or X11) Atom for a named string.  <a href="#gab9521326551eb30d23685ab9e4622666">More...</a><br /></td></tr>
<tr class="separator:gab9521326551eb30d23685ab9e4622666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga024ac0b11bace3a96d11ac62ec348e71"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__functions.html#ga024ac0b11bace3a96d11ac62ec348e71">WBGetAtomName</a> (Display *pDisplay, Atom aAtom)</td></tr>
<tr class="memdesc:ga024ac0b11bace3a96d11ac62ec348e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and/or allocate an internal Atom for a named string.  <a href="#ga024ac0b11bace3a96d11ac62ec348e71">More...</a><br /></td></tr>
<tr class="separator:ga024ac0b11bace3a96d11ac62ec348e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefaa2afddaf082501611eef7339b1edf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__functions.html#gaefaa2afddaf082501611eef7339b1edf">WBSearchPath</a> (const char *szFileName)</td></tr>
<tr class="memdesc:gaefaa2afddaf082501611eef7339b1edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">search for a file using the PATH environment variable  <a href="#gaefaa2afddaf082501611eef7339b1edf">More...</a><br /></td></tr>
<tr class="separator:gaefaa2afddaf082501611eef7339b1edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf82705f01778a667ddef2239899a2f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__functions.html#gabaf82705f01778a667ddef2239899a2f">WBTempFile</a> (const char *szExt)</td></tr>
<tr class="memdesc:gabaf82705f01778a667ddef2239899a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name for a new, unique temporary file, creating the file in the process, and save its name for later deletion.  <a href="#gabaf82705f01778a667ddef2239899a2f">More...</a><br /></td></tr>
<tr class="separator:gabaf82705f01778a667ddef2239899a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f8541b2e7204cafe39d514198b82826"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__functions.html#ga7f8541b2e7204cafe39d514198b82826">WBTempFile0</a> (const char *szExt)</td></tr>
<tr class="memdesc:ga7f8541b2e7204cafe39d514198b82826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name for a new, unique temporary file, creating the file in the process.  <a href="#ga7f8541b2e7204cafe39d514198b82826">More...</a><br /></td></tr>
<tr class="separator:ga7f8541b2e7204cafe39d514198b82826"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaa2be84e6aa35494ef5c78db3fe19886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa2be84e6aa35494ef5c78db3fe19886">&#9670;&nbsp;</a></span>my_qsort_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void my_qsort_r </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>thunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *, const void *, const void *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Local implementation of qsort_r() for operating systems that do not have it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to 'base' of items to sort </td></tr>
    <tr><td class="paramname">nmemb</td><td>Number of members to sort </td></tr>
    <tr><td class="paramname">size</td><td>Size of a single member (including any padding) </td></tr>
    <tr><td class="paramname">thunk</td><td>The value to pass along as the first parameter to 'compar' </td></tr>
    <tr><td class="paramname">compar</td><td>The comparison function, declared using DECLARE_SORT_FUNCTION</td></tr>
  </table>
  </dd>
</dl>
<p>This function implements the QSORT_R macro when there is no libc function for qsort_r()</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l02276">2276</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga24fcd397013eb85afa4077ef76849a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24fcd397013eb85afa4077ef76849a05">&#9670;&nbsp;</a></span>WBCPUCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WBCPUCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of available CPU cores. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of available CPU cores on the system. On a VM, only those cores that have been assigned to the VM will be counted.</dd></dl>
<p>A generic delay utility that returns the total number of available cores on the system. This may be useful when determining how to divide up a parallel algorithm, for example.</p>
<p>If the number of available cores is not known or cannot be determined for some reason, this function returns a value of 0.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l00759">759</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga99ffb9b6c8c93ea9e20706c62b4b7713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99ffb9b6c8c93ea9e20706c62b4b7713">&#9670;&nbsp;</a></span>WBCreatePointerHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__types.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a> WBCreatePointerHash </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pPointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create/obtain a 32-bit 'secure' hash for a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPointer</td><td>A pointer to memory that remains valid after the call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated 'hash' to the pointer. The hash should be free'd after use.</dd></dl>
<p>This function will create a 'secure' hash for a pointer. The hash can be used asynchronously for up to WB_SECURE_HASH_TIMEOUT milliseconds, after which the reference will automatically be free'd. In this way, an asynchronous message can contain references to pointers that are difficult to 'fake' if another application were to attempt to inject Events into the queue.</p>
<p>NOTE: automatically freeing the reference does NOT free the pointer. Failure to handle these correctly can result in memory leaks, but THAT is preferable to security vulnerabilities</p>
<p>If the same pointer is used more than once in a call to this function, and the hash is still 'valid', the same hash will be returned as before, but with a higher (internal) reference count. The timeout threshold will be reset using the current request time. This makes it 'thread safe'.</p>
<p>Passing a pointer asynchronously via a hash, particularly across thread boundaries, SHOULD implement its own method of reference counting to avoid re-using a pointer after the memory has been free'd. If you do not queue the message, this becomes less important. In any case, care needs to be taken to avoid using a pointer after it has been free'd.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l01593">1593</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga94004281108be87acc4fb37deef0a104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94004281108be87acc4fb37deef0a104">&#9670;&nbsp;</a></span>WBDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WBDelay </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>uiDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay for a specified period in microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uiDelay</td><td>The delay period, in microseconds</td></tr>
  </table>
  </dd>
</dl>
<p>A generic delay utility that will use 'nanosleep' (when available), or some other means (such as 'usleep') when it is not. On systems that do not support microsecond resolution on delays, this function will always delay at least one millisecond. On some systems, this delay may be interruptible. For exact timing, a non-interruptible loop that times execution by counting CPU instructions shyould be used instead. This function is approximate only.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l00733">733</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga966312c55d70aba382f3a9b714c024e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga966312c55d70aba382f3a9b714c024e2">&#9670;&nbsp;</a></span>WBDestroyPointerHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WBDestroyPointerHash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__platform__types.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a>&#160;</td>
          <td class="paramname"><em>uiHash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a 32-bit 'secure' hash for a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uiHash</td><td>The 'hash' value created by <a class="el" href="group__platform__functions.html#ga99ffb9b6c8c93ea9e20706c62b4b7713" title="Create/obtain a 32-bit &#39;secure&#39; hash for a pointer. ">WBCreatePointerHash()</a></td></tr>
  </table>
  </dd>
</dl>
<p>This function will reduce the reference count on a 'secure' hash for a pointer that was created by <a class="el" href="group__platform__functions.html#ga99ffb9b6c8c93ea9e20706c62b4b7713" title="Create/obtain a 32-bit &#39;secure&#39; hash for a pointer. ">WBCreatePointerHash()</a>. When the reference count reaches zero, the hash itself will be destroyed.</p>
<p>NOTE: destroying the hash reference does NOT free the pointer. Failure to handle these correctly can result in memory leaks, but that is preferable to security vulnerabilities</p>
<p>You should call this function immediately, once you have completed using a 'secure' pointer hash, particularly if it was received as part of an Event. In some cases, this will be done for you, such as via <a class="el" href="group__events.html#gaf6df53fd27da18e4a5a0ad5077c45a21" title="Dispatches a window XEvent. May be called directly. ">WBWindowDispatch()</a> with certain ClientMessage events. In other cases, you will have to explicitly do this yourself.</p>
<p>If you have physically free'd (or otherwise invalidated) a hashed pointer, you should call <a class="el" href="group__platform__functions.html#ga9c295f7a7fb34ed8f99a6abaa598b8a8" title="Destroy a 32-bit &#39;secure&#39; hash for a pointer regardless of reference count. ">WBDestroyPointerHashPtr()</a> so that a hash for that pointer will not exist.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l01749">1749</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga9c295f7a7fb34ed8f99a6abaa598b8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c295f7a7fb34ed8f99a6abaa598b8a8">&#9670;&nbsp;</a></span>WBDestroyPointerHashPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WBDestroyPointerHashPtr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pPointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a 32-bit 'secure' hash for a pointer regardless of reference count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPointer</td><td>A pointer for which a hash may exist</td></tr>
  </table>
  </dd>
</dl>
<p>This function will destroy a 'secure' hash for a pointer that was created by <a class="el" href="group__platform__functions.html#ga99ffb9b6c8c93ea9e20706c62b4b7713" title="Create/obtain a 32-bit &#39;secure&#39; hash for a pointer. ">WBCreatePointerHash()</a>, regardless of the reference count. The hash will remain valid for up to WB_SECURE_HASH_TIMEOUT milliseconds, but will have a value of 'NULL'. This helps to mitigate possible pointer re-use.</p>
<p>You should call this function immediately before you free a pointer that might be referenced by a secure pointer hash, to prevent 'use after free' problems. This will NOT solve problems where the hash is being used across threads, however. You may need to provide a different method of synchronizing hashes under such a condition, such as thread-safe reference counting.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l01817">1817</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gaf3ed97b8fd7aedff5948c1800fa59455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3ed97b8fd7aedff5948c1800fa59455">&#9670;&nbsp;</a></span>WBGetAtom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Atom WBGetAtom </td>
          <td>(</td>
          <td class="paramtype">Display *&#160;</td>
          <td class="paramname"><em>pDisplay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szAtomName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup and/or allocate an internal Atom for a named string (lookups include X11 atoms) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDisplay</td><td>The display to search for a matching X11 Atom </td></tr>
    <tr><td class="paramname">szAtomName</td><td>The text 'Atom name' to search (and optionally create) for an Atom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An Atom representing the specified szAtomName. For values less than WB_INTERNAL_ATOM_MIN_VAL, it will be an X11 Atom. Otherwise, the value will be 'internal only'</dd></dl>
<p>This function will lookup and/or allocate an internal Atom based on the specified Atom name. If the Atom name exists as an X11 Atom, or already exists as an internal atom, the function will return that value. Otherwise, this function will return an allocated Atom with a value &gt;= WB_INTERNAL_ATOM_MIN_VAL.</p>
<p>NOTE: If an X11 Atom with a matching name exists, along with an 'internal' definition, the internal definition will be returned. This is to prevent problems with a 'race condition' on an atom name.</p>
<p>If you need a globally defined atom with the matching name, use 'XInternAtom' instead. Internally defined atoms must never be used with other applications, window properties, or the window manager.</p>
<p>The X11 workbench toolkit makes use of Atoms for menu and dialog box events. To prevent flooding the X11 server with a lot of unnecessary proprietary Atom names, this function lets X11 workbench continue to use the Atom paradigm while simultaneously keeping its own separate, private list of Atoms.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l01964">1964</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga024ac0b11bace3a96d11ac62ec348e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga024ac0b11bace3a96d11ac62ec348e71">&#9670;&nbsp;</a></span>WBGetAtomName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* WBGetAtomName </td>
          <td>(</td>
          <td class="paramtype">Display *&#160;</td>
          <td class="paramname"><em>pDisplay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Atom&#160;</td>
          <td class="paramname"><em>aAtom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup and/or allocate an internal Atom for a named string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDisplay</td><td>The display to search for a matching X11 Atom </td></tr>
    <tr><td class="paramname">aAtom</td><td>The Atom to return the text for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated pointer containing the 'Atom name' text string. This pointer will need to be free'd using <a class="el" href="group__sub__alloc.html#gaebf9d7c0cd9aa525a93d0c5cc5376a1c" title="High performance memory sub-allocator &#39;free&#39;. ">WBFree()</a> (it is created via '<a class="el" href="group__text.html#ga01c938dde1b777421803b3e31c4717aa" title="A simple utility that returns a WBAlloc() copy of a 0-byte terminated string. ">WBCopyString()</a>')</dd></dl>
<p>This function returns the Atom name (as an allocated character string) associate with the specified Atom, whether the Atom is an X11 Atom or an internal 'X11 workbench toolkit' Atom.</p>
<p>The X11 workbench toolkit makes use of Atoms for menu and dialog box events. To prevent flooding the X11 server with a lot of unnecessary proprietary Atom names, this function lets X11 workbench continue to use the Atom paradigm while simultaneously keeping its own separate, private list of Atoms. This function is intended to be compatible with the X11 function 'XGetAtomName()' to simplify the implementation of the application's code.</p>
<p>A non-NULL return value must be free'd using '<a class="el" href="group__sub__alloc.html#gaebf9d7c0cd9aa525a93d0c5cc5376a1c" title="High performance memory sub-allocator &#39;free&#39;. ">WBFree()</a>' rather than 'XFree()' (as it would have been with 'XGetAtomName()'). This is primarily for future cross-platform compatibility.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l02152">2152</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gab5193bbf0de01aa9cb4c1d3ea8923448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5193bbf0de01aa9cb4c1d3ea8923448">&#9670;&nbsp;</a></span>WBGetPointerFromHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* WBGetPointerFromHash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__platform__types.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a>&#160;</td>
          <td class="paramname"><em>uiHash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a pointer from a 32-bit 'secure' pointer hash value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uiHash</td><td>The 'hash' value created by <a class="el" href="group__platform__functions.html#ga99ffb9b6c8c93ea9e20706c62b4b7713" title="Create/obtain a 32-bit &#39;secure&#39; hash for a pointer. ">WBCreatePointerHash()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated 'hash' to the pointer, or NULL if not valid. The hash should be destroyed immediately after use.</dd></dl>
<p>This function will create a 'secure' hash for a pointer. The hash can be used asynchronously for up to WB_SECURE_HASH_TIMEOUT milliseconds, after which it the referenced pointer will automatically be free'd.</p>
<p>In this way, an asynchronous message can contain references to pointers that are difficult to 'fake' if another application were to attempt to inject XEvents into the queue.</p>
<p>NOTE: automatically freeing the reference does NOT free the pointer. Failure to handle these correctly can result in memory leaks, but that is preferable to security vulnerabilities</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l01871">1871</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gadc42f83070453daa04ccf39dc842d93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc42f83070453daa04ccf39dc842d93b">&#9670;&nbsp;</a></span>WBGetTimeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__types.html#gafe03a6c44f6d9df7e0e4bf1e8f49967a">WB_UINT64</a> WBGetTimeIndex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current 'time index' (in microseconds) </p>
<dl class="section return"><dt>Returns</dt><dd>An unsigned 64-bit time index value, in microseconds</dd></dl>
<p>The 'time index' is the master timer that determines when a timer event will be generated. By design it uses a 64-bit integer that never 'wraps around' to zero. It is generally derived from the 'gettimeofday' API call for operating systems such as BSD and Linux that support the POSIX standard.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l00714">714</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gab9521326551eb30d23685ab9e4622666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9521326551eb30d23685ab9e4622666">&#9670;&nbsp;</a></span>WBLookupAtom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Atom WBLookupAtom </td>
          <td>(</td>
          <td class="paramtype">Display *&#160;</td>
          <td class="paramname"><em>pDisplay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szAtomName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup (but do not allocate) an internal (or X11) Atom for a named string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDisplay</td><td>The display to search for a matching X11 Atom </td></tr>
    <tr><td class="paramname">szAtomName</td><td>The text 'Atom name' to search for an Atom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An Atom representing the specified szAtomName. For values less than WB_INTERNAL_ATOM_MIN_VAL, it will be an X11 Atom. Otherwise, the value will be 'internal only'</dd></dl>
<p>If an atom is not found, this function will return 'None'. It does not allocate a new atom.</p>
<p>This function will lookup an internal (or X11) Atom based on the specified Atom name. If the Atom name exists as an X11 Atom, or already exists as an internal atom, the function will return that value. Otherwise, this function will return 'None'.</p>
<p>An internal atom will have a value &gt;= WB_INTERNAL_ATOM_MIN_VAL</p>
<p>NOTE: If an X11 Atom with a matching name exists, along with an 'internal' definition, the internal definition will be returned. This is to prevent problems with a 'race condition' on an atom name.</p>
<p>If you need a globally defined atom with the matching name, use 'XInternAtom' instead. Internally defined atoms must never be used with other applications, window properties, or the window manager.</p>
<p>The X11 workbench toolkit makes use of Atoms for menu and dialog box events. To prevent flooding the X11 server with a lot of unnecessary proprietary Atom names, this function lets X11 workbench continue to use the Atom paradigm while simultaneously keeping its own separate, private list of Atoms.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l02093">2093</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gaefaa2afddaf082501611eef7339b1edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefaa2afddaf082501611eef7339b1edf">&#9670;&nbsp;</a></span>WBSearchPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* WBSearchPath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szFileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>search for a file using the PATH environment variable </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szFileName</td><td>A const pointer to a character string containing a file or path name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A '<a class="el" href="group__sub__alloc.html#ga8ee962cea8e2f0cb52d1cab9057ffe6c" title="High performance memory sub-allocator &#39;allocate&#39;. ">WBAlloc()</a> pointer to a character string containing the ACTUAL path to the file</dd></dl>
<p>This function locates a file using the PATH environment variable and the value of 'szFileName' by testing the file (or directory name) using 'stat'. When the file (or directory) is located, this function returns the path name as a '<a class="el" href="group__sub__alloc.html#ga8ee962cea8e2f0cb52d1cab9057ffe6c" title="High performance memory sub-allocator &#39;allocate&#39;. ">WBAlloc()</a> string. If the file (or directory) cannot be located, the function returns NULL.<br />
The caller must '<a class="el" href="group__sub__alloc.html#gaebf9d7c0cd9aa525a93d0c5cc5376a1c" title="High performance memory sub-allocator &#39;free&#39;. ">WBFree()</a>' any non-NULL pointer returned by this function.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l03132">3132</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gabaf82705f01778a667ddef2239899a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaf82705f01778a667ddef2239899a2f">&#9670;&nbsp;</a></span>WBTempFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* WBTempFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szExt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name for a new, unique temporary file, creating the file in the process, and save its name for later deletion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szExt</td><td>A const pointer to a string containing the file's extension (without the '.'), or NULL if no extension is desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A '<a class="el" href="group__sub__alloc.html#ga8ee962cea8e2f0cb52d1cab9057ffe6c" title="High performance memory sub-allocator &#39;allocate&#39;. ">WBAlloc()</a> pointer to a character string containing fully qualified path to the file</dd></dl>
<p>This function obtains a unique temporary file name and then creates the file with a zero length, returning the name of the file in a <a class="el" href="group__sub__alloc.html#ga8ee962cea8e2f0cb52d1cab9057ffe6c" title="High performance memory sub-allocator &#39;allocate&#39;. ">WBAlloc()</a> character string. On error, it returns NULL.<br />
The actual location of the temporary file depends upon platform-specific parameters, such as environment variables and system settings.<br />
The caller must '<a class="el" href="group__sub__alloc.html#gaebf9d7c0cd9aa525a93d0c5cc5376a1c" title="High performance memory sub-allocator &#39;free&#39;. ">WBFree()</a>' any non-NULL pointer returned by this function.<br />
This function preserves the name of the file in a list of temporary files that need to be deleted once the application has terminated. This way an external application can keep the file open indefinitely, or even re-read the file, without negative effects. The '<a class="el" href="group__startup.html#ga186e21ce3badbba01435fa3e30bacd16" title="Resource &#39;free-up&#39; on exit (must call) ">WBPlatformOnExit()</a>' function will delete all temporary files that have been previously created by 'WBTempFile'.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l03377">3377</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga7f8541b2e7204cafe39d514198b82826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f8541b2e7204cafe39d514198b82826">&#9670;&nbsp;</a></span>WBTempFile0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* WBTempFile0 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szExt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name for a new, unique temporary file, creating the file in the process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szExt</td><td>A const pointer to a string containing the file's extension (without the '.'), or NULL if no extension is desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A '<a class="el" href="group__sub__alloc.html#ga8ee962cea8e2f0cb52d1cab9057ffe6c" title="High performance memory sub-allocator &#39;allocate&#39;. ">WBAlloc()</a> pointer to a character string containing fully qualified path to the file</dd></dl>
<p>This function obtains a unique temporary file name and then creates the file with a zero length, returning the name of the file in a <a class="el" href="group__sub__alloc.html#ga8ee962cea8e2f0cb52d1cab9057ffe6c" title="High performance memory sub-allocator &#39;allocate&#39;. ">WBAlloc()</a> character string. On error, it returns NULL.<br />
The actual location of the temporary file depends upon platform-specific parameters, such as environment variables and system settings.<br />
The caller must '<a class="el" href="group__sub__alloc.html#gaebf9d7c0cd9aa525a93d0c5cc5376a1c" title="High performance memory sub-allocator &#39;free&#39;. ">WBFree()</a>' any non-NULL pointer returned by this function.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l03261">3261</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Feb 10 2018 15:26:49 for X11workbench Toolkit by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>

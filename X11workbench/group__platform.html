<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>X11 Work Bench Toolkit: Platform-Helper Functions and Definitions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">X11 Work Bench Toolkit
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__platform.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Platform-Helper Functions and Definitions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5fdc7facea201bfce4ad308105f88d0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga5fdc7facea201bfce4ad308105f88d0c">INVALID_HANDLE_VALUE</a></td></tr>
<tr class="memdesc:ga5fdc7facea201bfce4ad308105f88d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">INVALID HANDLE VALUE equivalent.  <a href="#ga5fdc7facea201bfce4ad308105f88d0c">More...</a><br /></td></tr>
<tr class="separator:ga5fdc7facea201bfce4ad308105f88d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcb99ccc1b92686f4d81fc4d421f1324"><td class="memItemLeft" align="right" valign="top"><a id="gabcb99ccc1b92686f4d81fc4d421f1324"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gabcb99ccc1b92686f4d81fc4d421f1324">HAS_WB_UINT64_BUILTIN</a></td></tr>
<tr class="memdesc:gabcb99ccc1b92686f4d81fc4d421f1324"><td class="mdescLeft">&#160;</td><td class="mdescRight">defined whenever the 'WB_UINT64' data type is a 'built in' data type <br /></td></tr>
<tr class="separator:gabcb99ccc1b92686f4d81fc4d421f1324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga440b53a71a770adf0a937dd35c6cc2ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga440b53a71a770adf0a937dd35c6cc2ec">__PACKED__</a>&#160;&#160;&#160;/* platform dependent; actual def must be a blank or doxygen barphs on it */</td></tr>
<tr class="memdesc:ga440b53a71a770adf0a937dd35c6cc2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">PACKED definition.  <a href="#ga440b53a71a770adf0a937dd35c6cc2ec">More...</a><br /></td></tr>
<tr class="separator:ga440b53a71a770adf0a937dd35c6cc2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e072186273813195bb5c42ec9b978c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga8e072186273813195bb5c42ec9b978c2">DECLARE_SORT_FUNCTION</a>(fn_name,  p0,  p1,  p2)&#160;&#160;&#160;int fn_name(void *p0, const void *p1, const void *p2)</td></tr>
<tr class="memdesc:ga8e072186273813195bb5c42ec9b978c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to declare a sort function for <a class="el" href="group__platform.html#gace47742235ba7c59804024b08432cf72">QSORT_R</a>.  <a href="#ga8e072186273813195bb5c42ec9b978c2">More...</a><br /></td></tr>
<tr class="separator:ga8e072186273813195bb5c42ec9b978c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace47742235ba7c59804024b08432cf72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gace47742235ba7c59804024b08432cf72">QSORT_R</a>(base,  nmemb,  size,  thunk,  compar)&#160;&#160;&#160;<a class="el" href="group__platform.html#gaaa2be84e6aa35494ef5c78db3fe19886">my_qsort_r</a>((base),(nmemb),(size),(thunk),(compar))</td></tr>
<tr class="memdesc:gace47742235ba7c59804024b08432cf72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local implementation of qsort_r() for operating systems that do not have it.  <a href="#gace47742235ba7c59804024b08432cf72">More...</a><br /></td></tr>
<tr class="separator:gace47742235ba7c59804024b08432cf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga17e22d77ef26bafa95ceeffc51947c79"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga17e22d77ef26bafa95ceeffc51947c79">WB_INT32</a></td></tr>
<tr class="memdesc:ga17e22d77ef26bafa95ceeffc51947c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform abstract 32-bit integer.  <a href="#ga17e22d77ef26bafa95ceeffc51947c79">More...</a><br /></td></tr>
<tr class="separator:ga17e22d77ef26bafa95ceeffc51947c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad218d279d60b555a8a8a1e4e2e959469"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a></td></tr>
<tr class="memdesc:gad218d279d60b555a8a8a1e4e2e959469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform abstract unsigned 32-bit integer.  <a href="#gad218d279d60b555a8a8a1e4e2e959469">More...</a><br /></td></tr>
<tr class="separator:gad218d279d60b555a8a8a1e4e2e959469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e50b5bd3d4dc7ee134c20772268f0f"><td class="memItemLeft" align="right" valign="top">typedef long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga63e50b5bd3d4dc7ee134c20772268f0f">WB_INT64</a></td></tr>
<tr class="memdesc:ga63e50b5bd3d4dc7ee134c20772268f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform abstract 64-bit integer.  <a href="#ga63e50b5bd3d4dc7ee134c20772268f0f">More...</a><br /></td></tr>
<tr class="separator:ga63e50b5bd3d4dc7ee134c20772268f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe03a6c44f6d9df7e0e4bf1e8f49967a"><td class="memItemLeft" align="right" valign="top">typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gafe03a6c44f6d9df7e0e4bf1e8f49967a">WB_UINT64</a></td></tr>
<tr class="memdesc:gafe03a6c44f6d9df7e0e4bf1e8f49967a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform abstract unsigned 64-bit integer.  <a href="#gafe03a6c44f6d9df7e0e4bf1e8f49967a">More...</a><br /></td></tr>
<tr class="separator:gafe03a6c44f6d9df7e0e4bf1e8f49967a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2e76d8f9feb32fb9105142299c90a5a"><td class="memItemLeft" align="right" valign="top">typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaf2e76d8f9feb32fb9105142299c90a5a">WB_UINTPTR</a></td></tr>
<tr class="memdesc:gaf2e76d8f9feb32fb9105142299c90a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform abstract unsigned integer that matches pointer size.  <a href="#gaf2e76d8f9feb32fb9105142299c90a5a">More...</a><br /></td></tr>
<tr class="separator:gaf2e76d8f9feb32fb9105142299c90a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f0672ea4d50fd29e009c4945778a92a"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7f0672ea4d50fd29e009c4945778a92a">WB_MODULE</a></td></tr>
<tr class="memdesc:ga7f0672ea4d50fd29e009c4945778a92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">MODULE HANDLE equivalent.  <a href="#ga7f0672ea4d50fd29e009c4945778a92a">More...</a><br /></td></tr>
<tr class="separator:ga7f0672ea4d50fd29e009c4945778a92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed85c9ea8560e7d4f32ebaaaa6318491"><td class="memItemLeft" align="right" valign="top">typedef pthread_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaed85c9ea8560e7d4f32ebaaaa6318491">WB_THREAD</a></td></tr>
<tr class="memdesc:gaed85c9ea8560e7d4f32ebaaaa6318491"><td class="mdescLeft">&#160;</td><td class="mdescRight">THREAD HANDLE equivalent.  <a href="#gaed85c9ea8560e7d4f32ebaaaa6318491">More...</a><br /></td></tr>
<tr class="separator:gaed85c9ea8560e7d4f32ebaaaa6318491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadec33de02b83d9f226bcb27b58f14366"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gadec33de02b83d9f226bcb27b58f14366">WB_PROCADDRESS</a>) (void)</td></tr>
<tr class="memdesc:gadec33de02b83d9f226bcb27b58f14366"><td class="mdescLeft">&#160;</td><td class="mdescRight">PROC ADDRESS equivalent.  <a href="#gadec33de02b83d9f226bcb27b58f14366">More...</a><br /></td></tr>
<tr class="separator:gadec33de02b83d9f226bcb27b58f14366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3410aa1fb5aa0102fd6c22106fd2026"><td class="memItemLeft" align="right" valign="top">typedef pthread_key_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaf3410aa1fb5aa0102fd6c22106fd2026">WB_THREAD_KEY</a></td></tr>
<tr class="memdesc:gaf3410aa1fb5aa0102fd6c22106fd2026"><td class="mdescLeft">&#160;</td><td class="mdescRight">THREAD LOCAL STORAGE 'key' equivalent.  <a href="#gaf3410aa1fb5aa0102fd6c22106fd2026">More...</a><br /></td></tr>
<tr class="separator:gaf3410aa1fb5aa0102fd6c22106fd2026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeace32381518224824f2a17a72763eed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__platform.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaeace32381518224824f2a17a72763eed">WB_COND</a></td></tr>
<tr class="memdesc:gaeace32381518224824f2a17a72763eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">CONDITION HANDLE equivalent (similar to an 'event')  <a href="#gaeace32381518224824f2a17a72763eed">More...</a><br /></td></tr>
<tr class="separator:gaeace32381518224824f2a17a72763eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5645870e43e8bbd2296cc08fbd87e1c8"><td class="memItemLeft" align="right" valign="top">typedef pthread_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga5645870e43e8bbd2296cc08fbd87e1c8">WB_MUTEX</a></td></tr>
<tr class="memdesc:ga5645870e43e8bbd2296cc08fbd87e1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">MUTEX HANDLE equivalent.  <a href="#ga5645870e43e8bbd2296cc08fbd87e1c8">More...</a><br /></td></tr>
<tr class="separator:ga5645870e43e8bbd2296cc08fbd87e1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadc42f83070453daa04ccf39dc842d93b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform.html#gafe03a6c44f6d9df7e0e4bf1e8f49967a">WB_UINT64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gadc42f83070453daa04ccf39dc842d93b">WBGetTimeIndex</a> (void)</td></tr>
<tr class="memdesc:gadc42f83070453daa04ccf39dc842d93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current 'time index' (in microseconds)  <a href="#gadc42f83070453daa04ccf39dc842d93b">More...</a><br /></td></tr>
<tr class="separator:gadc42f83070453daa04ccf39dc842d93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94004281108be87acc4fb37deef0a104"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga94004281108be87acc4fb37deef0a104">WBDelay</a> (uint32_t uiDelay)</td></tr>
<tr class="memdesc:ga94004281108be87acc4fb37deef0a104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay for a specified period in microseconds.  <a href="#ga94004281108be87acc4fb37deef0a104">More...</a><br /></td></tr>
<tr class="separator:ga94004281108be87acc4fb37deef0a104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fcd397013eb85afa4077ef76849a05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga24fcd397013eb85afa4077ef76849a05">WBCPUCount</a> (void)</td></tr>
<tr class="memdesc:ga24fcd397013eb85afa4077ef76849a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of available CPU cores.  <a href="#ga24fcd397013eb85afa4077ef76849a05">More...</a><br /></td></tr>
<tr class="separator:ga24fcd397013eb85afa4077ef76849a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa2be84e6aa35494ef5c78db3fe19886"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaaa2be84e6aa35494ef5c78db3fe19886">my_qsort_r</a> (void *base, int nmemb, int size, void *thunk, int(*compar)(void *, const void *, const void *))</td></tr>
<tr class="memdesc:gaaa2be84e6aa35494ef5c78db3fe19886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local implementation of qsort_r() for operating systems that do not have it.  <a href="#gaaa2be84e6aa35494ef5c78db3fe19886">More...</a><br /></td></tr>
<tr class="separator:gaaa2be84e6aa35494ef5c78db3fe19886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ffb9b6c8c93ea9e20706c62b4b7713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga99ffb9b6c8c93ea9e20706c62b4b7713">WBCreatePointerHash</a> (void *pPointer)</td></tr>
<tr class="memdesc:ga99ffb9b6c8c93ea9e20706c62b4b7713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create/obtain a 32-bit 'secure' hash for a pointer.  <a href="#ga99ffb9b6c8c93ea9e20706c62b4b7713">More...</a><br /></td></tr>
<tr class="separator:ga99ffb9b6c8c93ea9e20706c62b4b7713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966312c55d70aba382f3a9b714c024e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga966312c55d70aba382f3a9b714c024e2">WBDestroyPointerHash</a> (<a class="el" href="group__platform.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a> uiHash)</td></tr>
<tr class="memdesc:ga966312c55d70aba382f3a9b714c024e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a 32-bit 'secure' hash for a pointer.  <a href="#ga966312c55d70aba382f3a9b714c024e2">More...</a><br /></td></tr>
<tr class="separator:ga966312c55d70aba382f3a9b714c024e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c295f7a7fb34ed8f99a6abaa598b8a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9c295f7a7fb34ed8f99a6abaa598b8a8">WBDestroyPointerHashPtr</a> (void *pPointer)</td></tr>
<tr class="memdesc:ga9c295f7a7fb34ed8f99a6abaa598b8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a 32-bit 'secure' hash for a pointer regardless of reference count.  <a href="#ga9c295f7a7fb34ed8f99a6abaa598b8a8">More...</a><br /></td></tr>
<tr class="separator:ga9c295f7a7fb34ed8f99a6abaa598b8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5193bbf0de01aa9cb4c1d3ea8923448"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gab5193bbf0de01aa9cb4c1d3ea8923448">WBGetPointerFromHash</a> (<a class="el" href="group__platform.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a> uiHash)</td></tr>
<tr class="memdesc:gab5193bbf0de01aa9cb4c1d3ea8923448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a pointer from a 32-bit 'secure' pointer hash value.  <a href="#gab5193bbf0de01aa9cb4c1d3ea8923448">More...</a><br /></td></tr>
<tr class="separator:gab5193bbf0de01aa9cb4c1d3ea8923448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ed97b8fd7aedff5948c1800fa59455"><td class="memItemLeft" align="right" valign="top">Atom&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaf3ed97b8fd7aedff5948c1800fa59455">WBGetAtom</a> (Display *pDisplay, const char *szAtomName)</td></tr>
<tr class="memdesc:gaf3ed97b8fd7aedff5948c1800fa59455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and/or allocate an internal Atom for a named string (lookups include X11 atoms)  <a href="#gaf3ed97b8fd7aedff5948c1800fa59455">More...</a><br /></td></tr>
<tr class="separator:gaf3ed97b8fd7aedff5948c1800fa59455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9521326551eb30d23685ab9e4622666"><td class="memItemLeft" align="right" valign="top">Atom&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gab9521326551eb30d23685ab9e4622666">WBLookupAtom</a> (Display *pDisplay, const char *szAtomName)</td></tr>
<tr class="memdesc:gab9521326551eb30d23685ab9e4622666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup (but do not allocate) an internal (or X11) Atom for a named string.  <a href="#gab9521326551eb30d23685ab9e4622666">More...</a><br /></td></tr>
<tr class="separator:gab9521326551eb30d23685ab9e4622666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga024ac0b11bace3a96d11ac62ec348e71"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga024ac0b11bace3a96d11ac62ec348e71">WBGetAtomName</a> (Display *pDisplay, Atom aAtom)</td></tr>
<tr class="memdesc:ga024ac0b11bace3a96d11ac62ec348e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and/or allocate an internal Atom for a named string.  <a href="#ga024ac0b11bace3a96d11ac62ec348e71">More...</a><br /></td></tr>
<tr class="separator:ga024ac0b11bace3a96d11ac62ec348e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefaa2afddaf082501611eef7339b1edf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaefaa2afddaf082501611eef7339b1edf">WBSearchPath</a> (const char *szFileName)</td></tr>
<tr class="memdesc:gaefaa2afddaf082501611eef7339b1edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run an application asynchronously.  <a href="#gaefaa2afddaf082501611eef7339b1edf">More...</a><br /></td></tr>
<tr class="separator:gaefaa2afddaf082501611eef7339b1edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf82705f01778a667ddef2239899a2f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gabaf82705f01778a667ddef2239899a2f">WBTempFile</a> (const char *szExt)</td></tr>
<tr class="memdesc:gabaf82705f01778a667ddef2239899a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name for a new, unique temporary file, creating the file in the process, and save its name for later deletion.  <a href="#gabaf82705f01778a667ddef2239899a2f">More...</a><br /></td></tr>
<tr class="separator:gabaf82705f01778a667ddef2239899a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f8541b2e7204cafe39d514198b82826"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7f8541b2e7204cafe39d514198b82826">WBTempFile0</a> (const char *szExt)</td></tr>
<tr class="memdesc:ga7f8541b2e7204cafe39d514198b82826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name for a new, unique temporary file, creating the file in the process.  <a href="#ga7f8541b2e7204cafe39d514198b82826">More...</a><br /></td></tr>
<tr class="separator:ga7f8541b2e7204cafe39d514198b82826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71d10c657cde4801e8f2214f0d2c85d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga71d10c657cde4801e8f2214f0d2c85d3">WB_UNLIKELY</a>(x)&#160;&#160;&#160;(__builtin_expect (!!(x), 0))</td></tr>
<tr class="separator:ga71d10c657cde4801e8f2214f0d2c85d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5703d8802f856a5daf543e0c35caa48f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga5703d8802f856a5daf543e0c35caa48f">WB_LIKELY</a>(x)&#160;&#160;&#160;(__builtin_expect (!!(x), 1))</td></tr>
<tr class="separator:ga5703d8802f856a5daf543e0c35caa48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46643c5e1b93235a48a6acf67664ecb3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga46643c5e1b93235a48a6acf67664ecb3">WB_UNUSED</a>&#160;&#160;&#160;__attribute__((unused))</td></tr>
<tr class="separator:ga46643c5e1b93235a48a6acf67664ecb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bad3985812a598774350fb2a70839e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga8bad3985812a598774350fb2a70839e3">WB_INTERNAL_ATOM_MIN_VAL</a>&#160;&#160;&#160;0x3f000000L</td></tr>
<tr class="memdesc:ga8bad3985812a598774350fb2a70839e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum 'internal' Atom value used by the toolkit.  <a href="#ga8bad3985812a598774350fb2a70839e3">More...</a><br /></td></tr>
<tr class="separator:ga8bad3985812a598774350fb2a70839e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbebee81dd0645b706d5d9ffe4e3e977"><td class="memItemLeft" align="right" valign="top"><a id="gafbebee81dd0645b706d5d9ffe4e3e977"></a>
typedef char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gafbebee81dd0645b706d5d9ffe4e3e977">WB_PSTR</a></td></tr>
<tr class="memdesc:gafbebee81dd0645b706d5d9ffe4e3e977"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to char string - a convenience typedef <br /></td></tr>
<tr class="separator:gafbebee81dd0645b706d5d9ffe4e3e977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60eae15c5ce7bd699bea5ff126df6212"><td class="memItemLeft" align="right" valign="top"><a id="ga60eae15c5ce7bd699bea5ff126df6212"></a>
typedef const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga60eae15c5ce7bd699bea5ff126df6212">WB_PCSTR</a></td></tr>
<tr class="memdesc:ga60eae15c5ce7bd699bea5ff126df6212"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to const char string - a convenience typedef <br /></td></tr>
<tr class="separator:ga60eae15c5ce7bd699bea5ff126df6212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae106384a618f9454b4b2e78934aa8e93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gae106384a618f9454b4b2e78934aa8e93">WB_SECURE_HASH_TIMEOUT</a>&#160;&#160;&#160;60000</td></tr>
<tr class="separator:gae106384a618f9454b4b2e78934aa8e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Some functions either need special help on certain platforms, or are missing entirely. In other cases, the manner in which a function is implemented is very specific for a particular platform. Additionally, common definitions change from one platform to another. The functions and definitions in this group deal with these specific problems.<br />
</p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga440b53a71a770adf0a937dd35c6cc2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga440b53a71a770adf0a937dd35c6cc2ec">&#9670;&nbsp;</a></span>__PACKED__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __PACKED__&#160;&#160;&#160;/* platform dependent; actual def must be a blank or doxygen barphs on it */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PACKED definition. </p>
<p>This assignes the 'packed' attribute; i.e. byte-level alignment </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00347">347</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="ga8e072186273813195bb5c42ec9b978c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e072186273813195bb5c42ec9b978c2">&#9670;&nbsp;</a></span>DECLARE_SORT_FUNCTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECLARE_SORT_FUNCTION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fn_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;int fn_name(void *p0, const void *p1, const void *p2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper to declare a sort function for <a class="el" href="group__platform.html#gace47742235ba7c59804024b08432cf72">QSORT_R</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn_name</td><td>The function name </td></tr>
    <tr><td class="paramname">p0</td><td>The 'thunk' parameter passed in by QSORT_R </td></tr>
    <tr><td class="paramname">p1</td><td>The first compare parameter </td></tr>
    <tr><td class="paramname">p2</td><td>The second compare parameter</td></tr>
  </table>
  </dd>
</dl>
<p>Use this wrapper macro to properly declare a compare function for <a class="el" href="group__platform.html#gace47742235ba7c59804024b08432cf72">QSORT_R</a>, similar to the following example:</p>
<div class="fragment"><div class="line"><a class="code" href="group__platform.html#ga8e072186273813195bb5c42ec9b978c2">DECLARE_SORT_FUNCTION</a>(MySort,pThunk,pParam1,pParam2)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> **pStringArray = (<span class="keyword">const</span> <span class="keywordtype">char</span> **)pThunk; <span class="comment">// the real data</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> *pP1 = (<span class="keyword">const</span> <span class="keywordtype">int</span> *)pParam1;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> *pP2 = (<span class="keyword">const</span> <span class="keywordtype">int</span> *)pParam2;</div><div class="line"></div><div class="line">  <span class="comment">// I am sorting integer indices into an array of character strings so</span></div><div class="line">  <span class="comment">// that I can sort the integers and not the actual strings.  But I needed</span></div><div class="line">  <span class="comment">// a pointer to my string array, so I pass that in as &#39;pThunk&#39;.</span></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> strcmp(pStringArray[*pP1],pStringArray[*pP2]);</div><div class="line">}</div></div><!-- fragment --><p>this helps resolve the known platform differences in qsort_r() for POSIX systems</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__platform.html#gace47742235ba7c59804024b08432cf72" title="Local implementation of qsort_r() for operating systems that do not have it. ">QSORT_R</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l01109">1109</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="ga5fdc7facea201bfce4ad308105f88d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fdc7facea201bfce4ad308105f88d0c">&#9670;&nbsp;</a></span>INVALID_HANDLE_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INVALID_HANDLE_VALUE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>INVALID HANDLE VALUE equivalent. </p>
<p>This definition generically refers to an INVALID HANDLE, more specifically a FILE or SOCKET handle on POSIX systems </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00160">160</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="gace47742235ba7c59804024b08432cf72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace47742235ba7c59804024b08432cf72">&#9670;&nbsp;</a></span>QSORT_R</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QSORT_R</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">base, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nmemb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">thunk, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compar&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__platform.html#gaaa2be84e6aa35494ef5c78db3fe19886">my_qsort_r</a>((base),(nmemb),(size),(thunk),(compar))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Local implementation of qsort_r() for operating systems that do not have it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to 'base' of items to sort </td></tr>
    <tr><td class="paramname">nmemb</td><td>Number of members to sort </td></tr>
    <tr><td class="paramname">size</td><td>Size of a single member (including any padding) </td></tr>
    <tr><td class="paramname">thunk</td><td>The value to pass along as the first parameter to 'compar' </td></tr>
    <tr><td class="paramname">compar</td><td>The comparison function, declared using DECLARE_SORT_FUNCTION</td></tr>
  </table>
  </dd>
</dl>
<p>Use this UNIVERSALLY whenever you need to use qsort_r(), as it is platform independent and deals with the incompatibilities associated with the BSD version and the Linux version, as well as implementing qsort_r() for systems that do not support it directly. </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l01125">1125</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="ga8bad3985812a598774350fb2a70839e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bad3985812a598774350fb2a70839e3">&#9670;&nbsp;</a></span>WB_INTERNAL_ATOM_MIN_VAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WB_INTERNAL_ATOM_MIN_VAL&#160;&#160;&#160;0x3f000000L</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The minimum 'internal' Atom value used by the toolkit. </p>
<p>This is the minimum 'internal' Atom value that is used by the toolkit. Atoms that are allocated via XInternAtom() will have a value that is LESS than WB_INTERNAL_ATOM_MIN_VAL, and anything allocated via <a class="el" href="group__platform.html#gaf3ed97b8fd7aedff5948c1800fa59455" title="Lookup and/or allocate an internal Atom for a named string (lookups include X11 atoms) ...">WBGetAtom()</a> will have a value that is GREATER THAN OR EQUAL to WB_INTERNAL_ATOM_MIN_VAL.</p>
<p>Use of this constant to determine 'internal' from 'X11' Atoms is based on the source code for the Xorg X11 server, which uses the function 'MakeAtom()' (in 'dix/atom.c') to allocate new atoms. These values are assigned SEQUENTIALLY, beginning with 'XA_LAST_PREDEFINED+1' and continuing from there. A value of this magnitude allows for about 1 billion Atom allocations before 'hitting the limit'. (having that many atoms would negatively impact the X windows system)</p>
<p>In the future, it is possible that an Atom <em>MAY</em> have a randomly assigned value, or a value assigned that clashes with this definition. In such a case, a major re-write might be needed to correct for it.</p>
<p>NOTE: This value must NOT include any of the bits 'Or'd with an Atom within a menu, such as 'WBMENU_POPUP_HIGH_BIT' or 'WBMENU_DYNAMIC_HIGH_BIT'. Otherwise, THAT architecture would need to be modified as well.the minimum 'internal' Atom value used by the toolkit </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00212">212</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="ga5703d8802f856a5daf543e0c35caa48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5703d8802f856a5daf543e0c35caa48f">&#9670;&nbsp;</a></span>WB_LIKELY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WB_LIKELY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(__builtin_expect (!!(x), 1))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>optimization for code branching when condition is 'likely'. use within conditionals </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00174">174</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="gae106384a618f9454b4b2e78934aa8e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae106384a618f9454b4b2e78934aa8e93">&#9670;&nbsp;</a></span>WB_SECURE_HASH_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WB_SECURE_HASH_TIMEOUT&#160;&#160;&#160;60000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>'secure hash' maximum lifetime, in milliseconds </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00408">408</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="ga71d10c657cde4801e8f2214f0d2c85d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71d10c657cde4801e8f2214f0d2c85d3">&#9670;&nbsp;</a></span>WB_UNLIKELY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WB_UNLIKELY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(__builtin_expect (!!(x), 0))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>optimization for code branching when condition is 'unlikely'. use within conditionals </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00173">173</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="ga46643c5e1b93235a48a6acf67664ecb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46643c5e1b93235a48a6acf67664ecb3">&#9670;&nbsp;</a></span>WB_UNUSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WB_UNUSED&#160;&#160;&#160;__attribute__((unused))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>marks a variable as likely to be 'unused'. warning abatement. Place macro directly after the variable name </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00185">185</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaeace32381518224824f2a17a72763eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeace32381518224824f2a17a72763eed">&#9670;&nbsp;</a></span>WB_COND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__platform.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a> <a class="el" href="group__platform.html#gaeace32381518224824f2a17a72763eed">WB_COND</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CONDITION HANDLE equivalent (similar to an 'event') </p>
<p>This 'typedef' refers to a CONDITION, a triggerable synchronization resource </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00325">325</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="ga17e22d77ef26bafa95ceeffc51947c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17e22d77ef26bafa95ceeffc51947c79">&#9670;&nbsp;</a></span>WB_INT32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="group__platform.html#ga17e22d77ef26bafa95ceeffc51947c79">WB_INT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Platform abstract 32-bit integer. </p>
<p>This definition identifies the data type for a 32-bit integer </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00223">223</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="ga63e50b5bd3d4dc7ee134c20772268f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63e50b5bd3d4dc7ee134c20772268f0f">&#9670;&nbsp;</a></span>WB_INT64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long long <a class="el" href="group__platform.html#ga63e50b5bd3d4dc7ee134c20772268f0f">WB_INT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Platform abstract 64-bit integer. </p>
<p>This definition identifies the data type for a 64-bit integer </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00246">246</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="ga7f0672ea4d50fd29e009c4945778a92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f0672ea4d50fd29e009c4945778a92a">&#9670;&nbsp;</a></span>WB_MODULE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="group__platform.html#ga7f0672ea4d50fd29e009c4945778a92a">WB_MODULE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MODULE HANDLE equivalent. </p>
<p>This 'typedef' refers to a MODULE </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00297">297</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="ga5645870e43e8bbd2296cc08fbd87e1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5645870e43e8bbd2296cc08fbd87e1c8">&#9670;&nbsp;</a></span>WB_MUTEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pthread_mutex_t <a class="el" href="group__platform.html#ga5645870e43e8bbd2296cc08fbd87e1c8">WB_MUTEX</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MUTEX HANDLE equivalent. </p>
<p>This 'typedef' refers to a MUTEX, a lockable synchronization object </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00333">333</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="gadec33de02b83d9f226bcb27b58f14366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadec33de02b83d9f226bcb27b58f14366">&#9670;&nbsp;</a></span>WB_PROCADDRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*  WB_PROCADDRESS) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PROC ADDRESS equivalent. </p>
<p>This 'typedef' refers to a PROC ADDRESS as exported from a shared library </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00311">311</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="gaed85c9ea8560e7d4f32ebaaaa6318491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed85c9ea8560e7d4f32ebaaaa6318491">&#9670;&nbsp;</a></span>WB_THREAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pthread_t <a class="el" href="group__platform.html#gaed85c9ea8560e7d4f32ebaaaa6318491">WB_THREAD</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>THREAD HANDLE equivalent. </p>
<p>This 'typedef' refers to a THREAD </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00304">304</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="gaf3410aa1fb5aa0102fd6c22106fd2026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3410aa1fb5aa0102fd6c22106fd2026">&#9670;&nbsp;</a></span>WB_THREAD_KEY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pthread_key_t <a class="el" href="group__platform.html#gaf3410aa1fb5aa0102fd6c22106fd2026">WB_THREAD_KEY</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>THREAD LOCAL STORAGE 'key' equivalent. </p>
<p>This 'typedef' refers to a THREAD LOCAL STORAGE key, identifying a storage slot </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00318">318</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="gad218d279d60b555a8a8a1e4e2e959469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad218d279d60b555a8a8a1e4e2e959469">&#9670;&nbsp;</a></span>WB_UINT32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="group__platform.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Platform abstract unsigned 32-bit integer. </p>
<p>This definition identifies the data type for an unsigned 32-bit integer </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00230">230</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="gafe03a6c44f6d9df7e0e4bf1e8f49967a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe03a6c44f6d9df7e0e4bf1e8f49967a">&#9670;&nbsp;</a></span>WB_UINT64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long long <a class="el" href="group__platform.html#gafe03a6c44f6d9df7e0e4bf1e8f49967a">WB_UINT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Platform abstract unsigned 64-bit integer. </p>
<p>This definition identifies the data type for an unsigned 64-bit integer </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00253">253</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<a id="gaf2e76d8f9feb32fb9105142299c90a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2e76d8f9feb32fb9105142299c90a5a">&#9670;&nbsp;</a></span>WB_UINTPTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long long <a class="el" href="group__platform.html#gaf2e76d8f9feb32fb9105142299c90a5a">WB_UINTPTR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Platform abstract unsigned integer that matches pointer size. </p>
<p>Definition for an integer equivalent of a pointer for platform-independent type casting without warnings </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8h_source.html#l00268">268</a> of file <a class="el" href="platform__helper_8h_source.html">platform_helper.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaa2be84e6aa35494ef5c78db3fe19886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa2be84e6aa35494ef5c78db3fe19886">&#9670;&nbsp;</a></span>my_qsort_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void my_qsort_r </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>thunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *, const void *, const void *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Local implementation of qsort_r() for operating systems that do not have it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to 'base' of items to sort </td></tr>
    <tr><td class="paramname">nmemb</td><td>Number of members to sort </td></tr>
    <tr><td class="paramname">size</td><td>Size of a single member (including any padding) </td></tr>
    <tr><td class="paramname">thunk</td><td>The value to pass along as the first parameter to 'compar' </td></tr>
    <tr><td class="paramname">compar</td><td>The comparison function, declared using DECLARE_SORT_FUNCTION</td></tr>
  </table>
  </dd>
</dl>
<p>This function implements the QSORT_R macro when there is no libc function for qsort_r()</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l02276">2276</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga24fcd397013eb85afa4077ef76849a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24fcd397013eb85afa4077ef76849a05">&#9670;&nbsp;</a></span>WBCPUCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WBCPUCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of available CPU cores. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of available CPU cores on the system. On a VM, only those cores that have been assigned to the VM will be counted.</dd></dl>
<p>A generic delay utility that returns the total number of available cores on the system. This may be useful when determining how to divide up a parallel algorithm, for example.</p>
<p>If the number of available cores is not known or cannot be determined for some reason, this function returns a value of 0.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l00759">759</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga99ffb9b6c8c93ea9e20706c62b4b7713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99ffb9b6c8c93ea9e20706c62b4b7713">&#9670;&nbsp;</a></span>WBCreatePointerHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a> WBCreatePointerHash </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pPointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create/obtain a 32-bit 'secure' hash for a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPointer</td><td>A pointer to memory that remains valid after the call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated 'hash' to the pointer. The hash should be free'd after use.</dd></dl>
<p>This function will create a 'secure' hash for a pointer. The hash can be used asynchronously for up to WB_SECURE_HASH_TIMEOUT milliseconds, after which it the reference automatically be free'd. In this way, an asynchronous message can contain references to pointers that are difficult to 'fake' if another application were to attempt to inject Events into the queue.</p>
<p>NOTE: automatically freeing the reference does NOT free the pointer. Failure to handle these correctly can result in memory leaks, but THAT is preferable to security vulnerabilities</p>
<p>If the same pointer is used more than once in a call to this function, and the hash is still 'valid', the same hash will be returned as before, but with a higher (internal) reference count. The timeout threshold will be reset using the current request time. This makes it 'thread safe'.</p>
<p>Passing a pointer asynchronously via a hash, particularly across thread boundaries, SHOULD implement its own method of reference counting to avoid re-using a pointer after the memory has been free'd. If you do not queue the message, this becomes less important. In any case, care needs to be taken to avoid using a pointer after it has been free'd.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l01593">1593</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga94004281108be87acc4fb37deef0a104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94004281108be87acc4fb37deef0a104">&#9670;&nbsp;</a></span>WBDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WBDelay </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>uiDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay for a specified period in microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uiDelay</td><td>The delay period, in microseconds</td></tr>
  </table>
  </dd>
</dl>
<p>A generic delay utility that will use 'nanosleep' (when available), or some other means (such as 'usleep') when it is not. On systems that do not support microsecond resolution on delays, this function will always delay at least one millisecond. On some systems, this delay may be interruptible. For exact timing, a non-interruptible loop that times execution by counting CPU instructions shyould be used instead. This function is approximate only.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l00733">733</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga966312c55d70aba382f3a9b714c024e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga966312c55d70aba382f3a9b714c024e2">&#9670;&nbsp;</a></span>WBDestroyPointerHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WBDestroyPointerHash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__platform.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a>&#160;</td>
          <td class="paramname"><em>uiHash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a 32-bit 'secure' hash for a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uiHash</td><td>The 'hash' value created by <a class="el" href="group__platform.html#ga99ffb9b6c8c93ea9e20706c62b4b7713" title="Create/obtain a 32-bit &#39;secure&#39; hash for a pointer. ">WBCreatePointerHash()</a></td></tr>
  </table>
  </dd>
</dl>
<p>This function will destroy a 'secure' hash for a pointer that was created by <a class="el" href="group__platform.html#ga99ffb9b6c8c93ea9e20706c62b4b7713" title="Create/obtain a 32-bit &#39;secure&#39; hash for a pointer. ">WBCreatePointerHash()</a></p>
<p>NOTE: destroying the hash reference does NOT free the pointer. Failure to handle these correctly can result in memory leaks, but that is preferable to security vulnerabilities</p>
<p>You should call this function immediately, once you have completed using the 'secure' pointer hash. In some cases, this will be done for you (such as via <a class="el" href="group__events.html#gaf6df53fd27da18e4a5a0ad5077c45a21" title="Dispatches a window XEvent. May be called directly. ">WBWindowDispatch()</a> with certain ClientMessage events). In other cases, you will have to explicitly do this yourself.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l01749">1749</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga9c295f7a7fb34ed8f99a6abaa598b8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c295f7a7fb34ed8f99a6abaa598b8a8">&#9670;&nbsp;</a></span>WBDestroyPointerHashPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WBDestroyPointerHashPtr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pPointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a 32-bit 'secure' hash for a pointer regardless of reference count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPointer</td><td>A pointer for which a hash may exist</td></tr>
  </table>
  </dd>
</dl>
<p>This function will destroy a 'secure' hash for a pointer that was created by <a class="el" href="group__platform.html#ga99ffb9b6c8c93ea9e20706c62b4b7713" title="Create/obtain a 32-bit &#39;secure&#39; hash for a pointer. ">WBCreatePointerHash()</a>, regardless of the reference count. The hash will remain valid for up to WB_SECURE_HASH_TIMEOUT milliseconds, but will have a value of 'NULL'. This helps to mitigate possible pointer re-use.</p>
<p>You should call this function immediately before you free a pointer that might be referenced by a secure pointer hash, to prevent 'use after free' problems. This will NOT solve problems where the hash is being used across threads, however. You may need to provide a different method of synchronizing hashes under such a condition, such as thread-safe reference counting.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l01817">1817</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gaf3ed97b8fd7aedff5948c1800fa59455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3ed97b8fd7aedff5948c1800fa59455">&#9670;&nbsp;</a></span>WBGetAtom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Atom WBGetAtom </td>
          <td>(</td>
          <td class="paramtype">Display *&#160;</td>
          <td class="paramname"><em>pDisplay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szAtomName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup and/or allocate an internal Atom for a named string (lookups include X11 atoms) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDisplay</td><td>The display to search for a matching X11 Atom </td></tr>
    <tr><td class="paramname">szAtomName</td><td>The text 'Atom name' to search (and optionally create) for an Atom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An Atom representing the specified szAtomName. For values less than WB_INTERNAL_ATOM_MIN_VAL, it will be an X11 Atom. Otherwise, the value will be 'internal only'</dd></dl>
<p>This function will lookup and/or allocate an internal Atom based on the specified Atom name. If the Atom name exists as an X11 Atom, or already exists as an internal atom, the function will return that value. Otherwise, this function will return an allocated Atom with a value &gt;= WB_INTERNAL_ATOM_MIN_VAL.</p>
<p>NOTE: If an X11 Atom with a matching name exists, along with an 'internal' definition, the internal definition will be returned. This is to prevent problems with a 'race condition' on an atom name.</p>
<p>If you need a globally defined atom with the matching name, use 'XInternAtom' instead. Internally defined atoms must never be used with other applications, window properties, or the window manager.</p>
<p>The X11 workbench toolkit makes use of Atoms for menu and dialog box events. To prevent flooding the X11 server with a lot of unnecessary proprietary Atom names, this function lets X11 workbench continue to use the Atom paradigm while simultaneously keeping its own separate, private list of Atoms.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l01964">1964</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga024ac0b11bace3a96d11ac62ec348e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga024ac0b11bace3a96d11ac62ec348e71">&#9670;&nbsp;</a></span>WBGetAtomName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* WBGetAtomName </td>
          <td>(</td>
          <td class="paramtype">Display *&#160;</td>
          <td class="paramname"><em>pDisplay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Atom&#160;</td>
          <td class="paramname"><em>aAtom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup and/or allocate an internal Atom for a named string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDisplay</td><td>The display to search for a matching X11 Atom </td></tr>
    <tr><td class="paramname">aAtom</td><td>The Atom to return the text for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated pointer containing the 'Atom name' text string. This pointer will need to be free'd using <a class="el" href="group__sub__alloc.html#gaebf9d7c0cd9aa525a93d0c5cc5376a1c" title="High performance memory sub-allocator &#39;free&#39;. ">WBFree()</a> (it is created via '<a class="el" href="group__text.html#ga01c938dde1b777421803b3e31c4717aa" title="A simple utility that returns a WBAlloc() copy of a 0-byte terminated string. ">WBCopyString()</a>')</dd></dl>
<p>This function returns the Atom name (as an allocated character string) associate with the specified Atom, whether the Atom is an X11 Atom or an internal 'X11 workbench toolkit' Atom.</p>
<p>The X11 workbench toolkit makes use of Atoms for menu and dialog box events. To prevent flooding the X11 server with a lot of unnecessary proprietary Atom names, this function lets X11 workbench continue to use the Atom paradigm while simultaneously keeping its own separate, private list of Atoms. This function is intended to be compatible with the X11 function 'XGetAtomName()' to simplify the implementation of the application's code.</p>
<p>A non-NULL return value must be free'd using '<a class="el" href="group__sub__alloc.html#gaebf9d7c0cd9aa525a93d0c5cc5376a1c" title="High performance memory sub-allocator &#39;free&#39;. ">WBFree()</a>' rather than 'XFree()' (as it would have been with 'XGetAtomName()'). This is primarily for future cross-platform compatibility.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l02152">2152</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gab5193bbf0de01aa9cb4c1d3ea8923448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5193bbf0de01aa9cb4c1d3ea8923448">&#9670;&nbsp;</a></span>WBGetPointerFromHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* WBGetPointerFromHash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__platform.html#gad218d279d60b555a8a8a1e4e2e959469">WB_UINT32</a>&#160;</td>
          <td class="paramname"><em>uiHash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a pointer from a 32-bit 'secure' pointer hash value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uiHash</td><td>The 'hash' value created by <a class="el" href="group__platform.html#ga99ffb9b6c8c93ea9e20706c62b4b7713" title="Create/obtain a 32-bit &#39;secure&#39; hash for a pointer. ">WBCreatePointerHash()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated 'hash' to the pointer, or NULL if not valid. The hash should be destroyed immediately after use.</dd></dl>
<p>This function will create a 'secure' hash for a pointer. The hash can be used asynchronously for up to WB_SECURE_HASH_TIMEOUT milliseconds, after which it the referenced pointer will automatically be free'd.</p>
<p>In this way, an asynchronous message can contain references to pointers that are difficult to 'fake' if another application were to attempt to inject XEvents into the queue.</p>
<p>NOTE: automatically freeing the reference does NOT free the pointer. Failure to handle these correctly can result in memory leaks, but that is preferable to security vulnerabilities</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l01871">1871</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gadc42f83070453daa04ccf39dc842d93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc42f83070453daa04ccf39dc842d93b">&#9670;&nbsp;</a></span>WBGetTimeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform.html#gafe03a6c44f6d9df7e0e4bf1e8f49967a">WB_UINT64</a> WBGetTimeIndex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current 'time index' (in microseconds) </p>
<dl class="section return"><dt>Returns</dt><dd>An unsigned 64-bit time index value, in microseconds</dd></dl>
<p>The 'time index' is the master timer that determines when a timer event will be generated. By design it uses a 64-bit integer that never 'wraps around' to zero. It is generally derived from the 'gettimeofday' API call for operating systems such as BSD and Linux that support the POSIX standard.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l00714">714</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gab9521326551eb30d23685ab9e4622666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9521326551eb30d23685ab9e4622666">&#9670;&nbsp;</a></span>WBLookupAtom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Atom WBLookupAtom </td>
          <td>(</td>
          <td class="paramtype">Display *&#160;</td>
          <td class="paramname"><em>pDisplay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szAtomName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup (but do not allocate) an internal (or X11) Atom for a named string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDisplay</td><td>The display to search for a matching X11 Atom </td></tr>
    <tr><td class="paramname">szAtomName</td><td>The text 'Atom name' to search for an Atom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An Atom representing the specified szAtomName. For values less than WB_INTERNAL_ATOM_MIN_VAL, it will be an X11 Atom. Otherwise, the value will be 'internal only'</dd></dl>
<p>If an atom is not found, this function will return 'None'. It does not allocate a new atom.</p>
<p>This function will lookup an internal (or X11) Atom based on the specified Atom name. If the Atom name exists as an X11 Atom, or already exists as an internal atom, the function will return that value. Otherwise, this function will return 'None'.</p>
<p>An internal atom will have a value &gt;= WB_INTERNAL_ATOM_MIN_VAL</p>
<p>NOTE: If an X11 Atom with a matching name exists, along with an 'internal' definition, the internal definition will be returned. This is to prevent problems with a 'race condition' on an atom name.</p>
<p>If you need a globally defined atom with the matching name, use 'XInternAtom' instead. Internally defined atoms must never be used with other applications, window properties, or the window manager.</p>
<p>The X11 workbench toolkit makes use of Atoms for menu and dialog box events. To prevent flooding the X11 server with a lot of unnecessary proprietary Atom names, this function lets X11 workbench continue to use the Atom paradigm while simultaneously keeping its own separate, private list of Atoms.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l02093">2093</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gaefaa2afddaf082501611eef7339b1edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefaa2afddaf082501611eef7339b1edf">&#9670;&nbsp;</a></span>WBSearchPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* WBSearchPath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szFileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run an application asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szFileName</td><td>A const pointer to a character string containing a file or path name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A '<a class="el" href="group__sub__alloc.html#ga8ee962cea8e2f0cb52d1cab9057ffe6c" title="High performance memory sub-allocator &#39;allocate&#39;. ">WBAlloc()</a> pointer to a character string containing the ACTUAL path to the file</dd></dl>
<p>This function locates a file using the PATH environment variable and the value of 'szFileName' by testing the file (or directory name) using 'stat'. When the file (or directory) is located, this function returns the path name as a '<a class="el" href="group__sub__alloc.html#ga8ee962cea8e2f0cb52d1cab9057ffe6c" title="High performance memory sub-allocator &#39;allocate&#39;. ">WBAlloc()</a> string. If the file (or directory) cannot be located, the function returns NULL.<br />
The caller must '<a class="el" href="group__sub__alloc.html#gaebf9d7c0cd9aa525a93d0c5cc5376a1c" title="High performance memory sub-allocator &#39;free&#39;. ">WBFree()</a>' any non-NULL pointer returned by this function.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l03132">3132</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gabaf82705f01778a667ddef2239899a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaf82705f01778a667ddef2239899a2f">&#9670;&nbsp;</a></span>WBTempFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* WBTempFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szExt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name for a new, unique temporary file, creating the file in the process, and save its name for later deletion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szExt</td><td>A const pointer to a string containing the file's extension (without the '.'), or NULL if no extension is desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A '<a class="el" href="group__sub__alloc.html#ga8ee962cea8e2f0cb52d1cab9057ffe6c" title="High performance memory sub-allocator &#39;allocate&#39;. ">WBAlloc()</a> pointer to a character string containing fully qualified path to the file</dd></dl>
<p>This function obtains a unique temporary file name and then creates the file with a zero length, returning the name of the file in a <a class="el" href="group__sub__alloc.html#ga8ee962cea8e2f0cb52d1cab9057ffe6c" title="High performance memory sub-allocator &#39;allocate&#39;. ">WBAlloc()</a> character string. On error, it returns NULL.<br />
The actual location of the temporary file depends upon platform-specific parameters, such as environment variables and system settings.<br />
The caller must '<a class="el" href="group__sub__alloc.html#gaebf9d7c0cd9aa525a93d0c5cc5376a1c" title="High performance memory sub-allocator &#39;free&#39;. ">WBFree()</a>' any non-NULL pointer returned by this function.<br />
This function preserves the name of the file in a list of temporary files that need to be deleted once the application has terminated. This way an external application can keep the file open indefinitely, or even re-read the file, without negative effects. The '<a class="el" href="group__startup.html#ga186e21ce3badbba01435fa3e30bacd16" title="Resource &#39;free-up&#39; on exit (must call) ">WBPlatformOnExit()</a>' function will delete all temporary files that have been previously created by 'WBTempFile'.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l03377">3377</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga7f8541b2e7204cafe39d514198b82826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f8541b2e7204cafe39d514198b82826">&#9670;&nbsp;</a></span>WBTempFile0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* WBTempFile0 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szExt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name for a new, unique temporary file, creating the file in the process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szExt</td><td>A const pointer to a string containing the file's extension (without the '.'), or NULL if no extension is desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A '<a class="el" href="group__sub__alloc.html#ga8ee962cea8e2f0cb52d1cab9057ffe6c" title="High performance memory sub-allocator &#39;allocate&#39;. ">WBAlloc()</a> pointer to a character string containing fully qualified path to the file</dd></dl>
<p>This function obtains a unique temporary file name and then creates the file with a zero length, returning the name of the file in a <a class="el" href="group__sub__alloc.html#ga8ee962cea8e2f0cb52d1cab9057ffe6c" title="High performance memory sub-allocator &#39;allocate&#39;. ">WBAlloc()</a> character string. On error, it returns NULL.<br />
The actual location of the temporary file depends upon platform-specific parameters, such as environment variables and system settings.<br />
The caller must '<a class="el" href="group__sub__alloc.html#gaebf9d7c0cd9aa525a93d0c5cc5376a1c" title="High performance memory sub-allocator &#39;free&#39;. ">WBFree()</a>' any non-NULL pointer returned by this function.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions. ">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l03261">3261</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Feb 1 2018 17:00:58 for X11 Work Bench Toolkit by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>

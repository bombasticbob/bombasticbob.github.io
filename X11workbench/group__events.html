<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>X11 Work Bench Toolkit: Event Handling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">X11 Work Bench Toolkit
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__events.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Event Handling<div class="ingroups"><a class="el" href="group__core.html">Core API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga873795f7442d970037a691cd4e51792c"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#ga873795f7442d970037a691cd4e51792c">WBWinEvent</a>) (Window wID, XEvent *pEvent)</td></tr>
<tr class="memdesc:ga873795f7442d970037a691cd4e51792c"><td class="mdescLeft">&#160;</td><td class="mdescRight">event callback function type for window events  <a href="#ga873795f7442d970037a691cd4e51792c">More...</a><br /></td></tr>
<tr class="separator:ga873795f7442d970037a691cd4e51792c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2648b749bede99874e9ed979ce861f44"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#ga2648b749bede99874e9ed979ce861f44">WBAppEvent</a>) (XEvent *pEvent)</td></tr>
<tr class="memdesc:ga2648b749bede99874e9ed979ce861f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">event callback function type for application events  <a href="#ga2648b749bede99874e9ed979ce861f44">More...</a><br /></td></tr>
<tr class="separator:ga2648b749bede99874e9ed979ce861f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3f7502f7a233be633097abdefeb3db21"><td class="memItemLeft" align="right" valign="top">Time&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#ga3f7502f7a233be633097abdefeb3db21">WBGetLastEventTime</a> (void)</td></tr>
<tr class="memdesc:ga3f7502f7a233be633097abdefeb3db21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main message loop, high level API to check for and retrieve the next event.  <a href="#ga3f7502f7a233be633097abdefeb3db21">More...</a><br /></td></tr>
<tr class="separator:ga3f7502f7a233be633097abdefeb3db21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae65d3f6f49b844602dfc2ce6037fde09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#gae65d3f6f49b844602dfc2ce6037fde09">WBCheckGetEvent</a> (Display *pDisplay, XEvent *pEvent)</td></tr>
<tr class="memdesc:gae65d3f6f49b844602dfc2ce6037fde09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main message loop, high level API to check for and retrieve the next event.  <a href="#gae65d3f6f49b844602dfc2ce6037fde09">More...</a><br /></td></tr>
<tr class="separator:gae65d3f6f49b844602dfc2ce6037fde09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf7234ca254d2459a41bb6917b41ab60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#gacf7234ca254d2459a41bb6917b41ab60">WBWaitForEvent</a> (Display *pDisplay)</td></tr>
<tr class="memdesc:gacf7234ca254d2459a41bb6917b41ab60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for an event, blocking indefinitely.  <a href="#gacf7234ca254d2459a41bb6917b41ab60">More...</a><br /></td></tr>
<tr class="separator:gacf7234ca254d2459a41bb6917b41ab60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79275e72d837cef2b535e9feeb81074f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#ga79275e72d837cef2b535e9feeb81074f">WBDispatch</a> (XEvent *pEvent)</td></tr>
<tr class="memdesc:ga79275e72d837cef2b535e9feeb81074f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic Event Dispatcher, using message type to dispatch.  <a href="#ga79275e72d837cef2b535e9feeb81074f">More...</a><br /></td></tr>
<tr class="separator:ga79275e72d837cef2b535e9feeb81074f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a3789b26732b720b3e1b4334ec2e3e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#ga4a3789b26732b720b3e1b4334ec2e3e5">WBAppDispatch</a> (XEvent *pEvent)</td></tr>
<tr class="memdesc:ga4a3789b26732b720b3e1b4334ec2e3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches an application XEvent. May be called directly.  <a href="#ga4a3789b26732b720b3e1b4334ec2e3e5">More...</a><br /></td></tr>
<tr class="separator:ga4a3789b26732b720b3e1b4334ec2e3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6df53fd27da18e4a5a0ad5077c45a21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#gaf6df53fd27da18e4a5a0ad5077c45a21">WBWindowDispatch</a> (Window wID, XEvent *pEvent)</td></tr>
<tr class="memdesc:gaf6df53fd27da18e4a5a0ad5077c45a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches a window XEvent. May be called directly.  <a href="#gaf6df53fd27da18e4a5a0ad5077c45a21">More...</a><br /></td></tr>
<tr class="separator:gaf6df53fd27da18e4a5a0ad5077c45a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64cd93bb3d9b9ed06f787c7a1ee7df7f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#ga64cd93bb3d9b9ed06f787c7a1ee7df7f">WBEventName</a> (int iEventID)</td></tr>
<tr class="memdesc:ga64cd93bb3d9b9ed06f787c7a1ee7df7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">debug function to return the name of an X11 event  <a href="#ga64cd93bb3d9b9ed06f787c7a1ee7df7f">More...</a><br /></td></tr>
<tr class="separator:ga64cd93bb3d9b9ed06f787c7a1ee7df7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c303659d95901643983f88a38948b44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#ga0c303659d95901643983f88a38948b44">WBShowModal</a> (Window wID, int bMenuSplashFlag)</td></tr>
<tr class="memdesc:ga0c303659d95901643983f88a38948b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows a 'modal' window by processing events until the window closes.  <a href="#ga0c303659d95901643983f88a38948b44">More...</a><br /></td></tr>
<tr class="separator:ga0c303659d95901643983f88a38948b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1ece849fdeb1fc9c42f3565dcc35351"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#gac1ece849fdeb1fc9c42f3565dcc35351">WBEndModal</a> (Window wID, int iReturn)</td></tr>
<tr class="memdesc:gac1ece849fdeb1fc9c42f3565dcc35351"><td class="mdescLeft">&#160;</td><td class="mdescRight">End a modal window with a specific return value.  <a href="#gac1ece849fdeb1fc9c42f3565dcc35351">More...</a><br /></td></tr>
<tr class="separator:gac1ece849fdeb1fc9c42f3565dcc35351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaded67a2919c5cb862d512803fbcf21b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#gaded67a2919c5cb862d512803fbcf21b5">WBNextEvent</a> (Display *pDisplay, XEvent *pEvent)</td></tr>
<tr class="memdesc:gaded67a2919c5cb862d512803fbcf21b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level event queue wrapper. Implements the client-side event queue. Does not block if no events available.  <a href="#gaded67a2919c5cb862d512803fbcf21b5">More...</a><br /></td></tr>
<tr class="separator:gaded67a2919c5cb862d512803fbcf21b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70cadee7dfde0a884dfdb5a36f4bf6b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#ga70cadee7dfde0a884dfdb5a36f4bf6b5">WBPostEvent</a> (Window wID, XEvent *pEvent)</td></tr>
<tr class="memdesc:ga70cadee7dfde0a884dfdb5a36f4bf6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a copy of the specified event at the end of the regular (internal) event queue.  <a href="#ga70cadee7dfde0a884dfdb5a36f4bf6b5">More...</a><br /></td></tr>
<tr class="separator:ga70cadee7dfde0a884dfdb5a36f4bf6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1379e7531ae4e2b7f901b6e187623fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#gad1379e7531ae4e2b7f901b6e187623fe">WBPostPriorityEvent</a> (Window wID, XEvent *pEvent)</td></tr>
<tr class="memdesc:gad1379e7531ae4e2b7f901b6e187623fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a copy of the specified event at the end of the priority (internal) event queue.  <a href="#gad1379e7531ae4e2b7f901b6e187623fe">More...</a><br /></td></tr>
<tr class="separator:gad1379e7531ae4e2b7f901b6e187623fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58733a08aa8a56986313c090d56fa9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#gae58733a08aa8a56986313c090d56fa9c">WBPostDelayedEvent</a> (XEvent *pEvent, unsigned int nDelay)</td></tr>
<tr class="memdesc:gae58733a08aa8a56986313c090d56fa9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delays placing a copy of the specified event at the end of the regular (internal) event queue by a specified number of milliseconds.  <a href="#gae58733a08aa8a56986313c090d56fa9c">More...</a><br /></td></tr>
<tr class="separator:gae58733a08aa8a56986313c090d56fa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7db44fa0c4785345f944167a066209d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#ga7db44fa0c4785345f944167a066209d3">WBPostAppEvent</a> (XEvent *pEvent)</td></tr>
<tr class="memdesc:ga7db44fa0c4785345f944167a066209d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a copy of the specified event at the end of the priority (internal) event queue.  <a href="#ga7db44fa0c4785345f944167a066209d3">More...</a><br /></td></tr>
<tr class="separator:ga7db44fa0c4785345f944167a066209d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26c444fc559879a0457ad3915dc95041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#ga26c444fc559879a0457ad3915dc95041">WBPostDelayedSetFocusAppEvent</a> (Display *pDisplay, Window wID, Window wIDFrom, unsigned int nDelay)</td></tr>
<tr class="memdesc:ga26c444fc559879a0457ad3915dc95041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 'set focus' ClientMessage event for the application event handler.  <a href="#ga26c444fc559879a0457ad3915dc95041">More...</a><br /></td></tr>
<tr class="separator:ga26c444fc559879a0457ad3915dc95041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa43907ec0a4d340d1741d95c573d8de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#gafa43907ec0a4d340d1741d95c573d8de">WBProcessExposeEvent</a> (XExposeEvent *pEvent)</td></tr>
<tr class="memdesc:gafa43907ec0a4d340d1741d95c573d8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level event processing, internal handling of Expose events  <a href="#gafa43907ec0a4d340d1741d95c573d8de">More...</a><br /></td></tr>
<tr class="separator:gafa43907ec0a4d340d1741d95c573d8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f2b00666adc4ae2587894bcd3ae8d7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__events.html#ga1f2b00666adc4ae2587894bcd3ae8d7f">WBMouseCancel</a> (Display *pDisplay, Window wID)</td></tr>
<tr class="memdesc:ga1f2b00666adc4ae2587894bcd3ae8d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level event processing, internal handling of Expose events  <a href="#ga1f2b00666adc4ae2587894bcd3ae8d7f">More...</a><br /></td></tr>
<tr class="separator:ga1f2b00666adc4ae2587894bcd3ae8d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Event handling in X11 involves an event handler loop and methods by which the various events can be dispatched to window callback functions, or to the application's event handler. The X11workbench Toolkit API has provisinos for event prioritization, asynchronous processing, and the generation of 'internal events' (see <a class="el" href="group__xatoms.html#ga3677a73e79086a6b1a713cb90b1ae1d7">aWM_CHAR</a>, <a class="el" href="group__xatoms.html#ga2abefe7eb5dd5ab5706b7b9a6ea1c8a7">aWM_POINTER</a>, <a class="el" href="group__xatoms.html#ga5bac48715e457c87648fa360fd906a71">aWM_TIMER</a>). </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga2648b749bede99874e9ed979ce861f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2648b749bede99874e9ed979ce861f44">&#9670;&nbsp;</a></span>WBAppEvent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WBAppEvent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>event callback function type for application events </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEvent</td><td>A pointer to the XEvent structure passed to the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event-specific value. Typically returns zero if the event was not processed, non-zero if further processing is not necessary</dd></dl>
<p>An event callback for the application should be declared according to this defined type</p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8h_source.html#l00183">183</a> of file <a class="el" href="window__helper_8h_source.html">window_helper.h</a>.</p>

</div>
</div>
<a id="ga873795f7442d970037a691cd4e51792c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga873795f7442d970037a691cd4e51792c">&#9670;&nbsp;</a></span>WBWinEvent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WBWinEvent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>event callback function type for window events </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wID</td><td>The Window ID for the window receiving the event notification </td></tr>
    <tr><td class="paramname">pEvent</td><td>A pointer to the XEvent structure passed to the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event-specific value. Typically returns zero if the event was not processed, non-zero if further processing is not necessary</dd></dl>
<p>Event callbacks for windows should be declared according to this defined type</p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8h_source.html#l00171">171</a> of file <a class="el" href="window__helper_8h_source.html">window_helper.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4a3789b26732b720b3e1b4334ec2e3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a3789b26732b720b3e1b4334ec2e3e5">&#9670;&nbsp;</a></span>WBAppDispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WBAppDispatch </td>
          <td>(</td>
          <td class="paramtype">XEvent *&#160;</td>
          <td class="paramname"><em>pEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatches an application XEvent. May be called directly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEvent</td><td>A pointer to an XEvent structure to process</td></tr>
  </table>
  </dd>
</dl>
<p>Application events have a window ID of None, and are dispatched to the registered Application callback. In the absence of a callback, default processing is performed.</p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l04668">4668</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="gae65d3f6f49b844602dfc2ce6037fde09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae65d3f6f49b844602dfc2ce6037fde09">&#9670;&nbsp;</a></span>WBCheckGetEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WBCheckGetEvent </td>
          <td>(</td>
          <td class="paramtype">Display *&#160;</td>
          <td class="paramname"><em>pDisplay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XEvent *&#160;</td>
          <td class="paramname"><em>pEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main message loop, high level API to check for and retrieve the next event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDisplay</td><td>A pointer to the Display to query events on </td></tr>
    <tr><td class="paramname">pEvent</td><td>A pointer to an XEvent structure to receive the event data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-zero value if there is an event to be processed, otherwise zero</dd></dl>
<p>Implementation of the X11workbench Toolkit API is centered around the API's event loop processing. The main application should implement its message loop by repeatedly calling <a class="el" href="group__events.html#gae65d3f6f49b844602dfc2ce6037fde09" title="Main message loop, high level API to check for and retrieve the next event. ">WBCheckGetEvent()</a> or <a class="el" href="group__events.html#gaded67a2919c5cb862d512803fbcf21b5" title="low-level event queue wrapper. Implements the client-side event queue. Does not block if no events av...">WBNextEvent()</a> and passing any retrieved event to <a class="el" href="group__events.html#ga79275e72d837cef2b535e9feeb81074f">WBDispatch()</a>. Internally, <a class="el" href="group__events.html#gae65d3f6f49b844602dfc2ce6037fde09" title="Main message loop, high level API to check for and retrieve the next event. ">WBCheckGetEvent()</a> calls the X___CheckEvent functions correctly, dispatches Expose events for asynchronous processing, translates keyboard and pointer events, and handles internally queued events (such as timers and 'posted' events).</p>
<p>The function returns a non-zero value if there is an event is to be processed.</p>
<p>To correctly implement a message loop, your code should be similar to the following:<br />
</p><div class="fragment"><div class="line">  XEvent event;</div><div class="line"></div><div class="line">  <span class="keywordflow">while</span> ( !<a class="code" href="group__startup.html#gaa4167dc88ea153b2619cb8eb8e3e9c2f">bQuitFlag</a> )</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span>( !<a class="code" href="group__events.html#gae65d3f6f49b844602dfc2ce6037fde09">WBCheckGetEvent</a>(pX11Display, &amp;event) )</div><div class="line">    {</div><div class="line">      <span class="comment">// as needed, perform an iteration of background processing here</span></div><div class="line"></div><div class="line">      <span class="comment">// With nothing else to do, SLEEP if there is no event in the message queue</span></div><div class="line">      <span class="comment">// and no background processing to be performed.</span></div><div class="line">      <span class="comment">// (alternately, you could use WBWaitForEvent() if you do not need periodic</span></div><div class="line">      <span class="comment">//  wake-up for background processing)</span></div><div class="line"></div><div class="line"><span class="comment">// implementations that support &#39;nanosleep&#39; should use it</span></div><div class="line"><span class="preprocessor">#ifdef HAVE_NANOSLEEP</span></div><div class="line">      <span class="keyword">struct </span>timespec tsp;</div><div class="line">      tsp.tv_sec = 0;</div><div class="line">      tsp.tv_nsec = 1000000;  <span class="comment">// wait for 1 msec</span></div><div class="line"></div><div class="line">      nanosleep(&amp;tsp, NULL);</div><div class="line"><span class="preprocessor">#else  // HAVE_NANOSLEEP</span></div><div class="line"></div><div class="line">      usleep(1000);  <span class="comment">// 1000 microsecs - a POSIX alternative to &#39;nanosleep&#39;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif // HAVE_NANOSLEEP</span></div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="group__events.html#ga79275e72d837cef2b535e9feeb81074f">WBDispatch</a>(&amp;event);</div><div class="line">  }</div></div><!-- fragment --><p>NOTE: If you do not want to do any background processing, consider using <a class="el" href="group__events.html#gacf7234ca254d2459a41bb6917b41ab60" title="Wait for an event, blocking indefinitely. ">WBWaitForEvent()</a> instead of 'usleep' or 'nanosleep'.</p>
<p>To only retrieve 'internally queued' events, see <a class="el" href="group__events.html#gaded67a2919c5cb862d512803fbcf21b5" title="low-level event queue wrapper. Implements the client-side event queue. Does not block if no events av...">WBNextEvent()</a></p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l03813">3813</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="ga79275e72d837cef2b535e9feeb81074f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79275e72d837cef2b535e9feeb81074f">&#9670;&nbsp;</a></span>WBDispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WBDispatch </td>
          <td>(</td>
          <td class="paramtype">XEvent *&#160;</td>
          <td class="paramname"><em>pEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic Event Dispatcher, using message type to dispatch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEvent</td><td>A pointer to an XEvent structure to process</td></tr>
  </table>
  </dd>
</dl>
<p>Call this function to generically dispatch an XEvent. The application will need to check for a 'quit' state independently. See <a class="el" href="group__events.html#gaf6df53fd27da18e4a5a0ad5077c45a21" title="Dispatches a window XEvent. May be called directly. ">WBWindowDispatch()</a>, <a class="el" href="group__events.html#ga4a3789b26732b720b3e1b4334ec2e3e5" title="Dispatches an application XEvent. May be called directly. ">WBAppDispatch()</a></p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l04768">4768</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="gac1ece849fdeb1fc9c42f3565dcc35351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1ece849fdeb1fc9c42f3565dcc35351">&#9670;&nbsp;</a></span>WBEndModal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WBEndModal </td>
          <td>(</td>
          <td class="paramtype">Window&#160;</td>
          <td class="paramname"><em>wID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iReturn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End a modal window with a specific return value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wID</td><td>Window ID of the window that must end its modal loop </td></tr>
    <tr><td class="paramname">iReturn</td><td>The 'return' value from the modal loop - see <a class="el" href="group__events.html#ga0c303659d95901643983f88a38948b44">WBShowModal()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Call this function from within a modal window's event process to close the window and exit from WBShowModal with the specified value in 'iReturn'</p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l02275">2275</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="ga64cd93bb3d9b9ed06f787c7a1ee7df7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64cd93bb3d9b9ed06f787c7a1ee7df7f">&#9670;&nbsp;</a></span>WBEventName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* WBEventName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iEventID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>debug function to return the name of an X11 event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iEventID</td><td>An event type identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to an ASCII 0-byte terminated character string representing the event ID, or NULL</dd></dl>
<p>Intended primarily for debug messages, it returns a pointer to an ASCII string containing the name of the event, based on its event ID. The ID of the event is the value of 'type' within the XEvent structure.</p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l08769">8769</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="ga3f7502f7a233be633097abdefeb3db21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f7502f7a233be633097abdefeb3db21">&#9670;&nbsp;</a></span>WBGetLastEventTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Time WBGetLastEventTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main message loop, high level API to check for and retrieve the next event. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'Time' value for the last event that had a server timestamp</dd></dl>
<p>In some cases it's necessary to know an approximate value of the X server's timestamp. The message loop will capture the timestamp value whenever it can. Use this function to return the best known server time value for the default Display.</p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l03806">3806</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="ga1f2b00666adc4ae2587894bcd3ae8d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f2b00666adc4ae2587894bcd3ae8d7f">&#9670;&nbsp;</a></span>WBMouseCancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WBMouseCancel </td>
          <td>(</td>
          <td class="paramtype">Display *&#160;</td>
          <td class="paramname"><em>pDisplay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Window&#160;</td>
          <td class="paramname"><em>wID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level event processing, internal handling of Expose events </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDisplay</td><td>The display for the mouse activity. A value of NULL uses the default display, either for 'wID', or the system default if wID is 'None'. </td></tr>
    <tr><td class="paramname">wID</td><td>The window to post the 'WB_POINTER_CANCEL' message to. This window should have the input focus. A value of 'None' indicates the window with the input focus.</td></tr>
  </table>
  </dd>
</dl>
<p>Call this function to effectively 'cancel' any operation involving the mouse. This will un-do any 'drag' operations and send a WM_POINTER Client Message event with the 'WB_POINTER_CANCEL', and optionally un-grab the mouse (and keyboard, as needed). In the case of a Modal operation, this may differ from normal Asynchronous operations. Additionally, if there are any mouse messages already in the queue, this will not remove them. It will be up to the caller to deal with that. This function ONLY fixes the status and capture of the mouse.</p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l05445">5445</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="gaded67a2919c5cb862d512803fbcf21b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaded67a2919c5cb862d512803fbcf21b5">&#9670;&nbsp;</a></span>WBNextEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WBNextEvent </td>
          <td>(</td>
          <td class="paramtype">Display *&#160;</td>
          <td class="paramname"><em>pDisplay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XEvent *&#160;</td>
          <td class="paramname"><em>pEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level event queue wrapper. Implements the client-side event queue. Does not block if no events available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDisplay</td><td>The Display pointer to query events on </td></tr>
    <tr><td class="paramname">pEvent</td><td>A pointer to an XEvent structure to receive event info </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a non-zero value if an event was obtained, or zero if no event was available</dd></dl>
<p>Similar to XNextEvent, this function checks the internal event queues for an event. Unlike XNextEvent it does not wait for an event to be available before returning. The function returns zero if there are no events to be processed.</p>
<p>This function will not pull events out of the X server's event queue. It ONLY manages 'internal' queued events, prioritizing them as needed.</p>
<p>See <a class="el" href="group__events.html#gae65d3f6f49b844602dfc2ce6037fde09" title="Main message loop, high level API to check for and retrieve the next event. ">WBCheckGetEvent()</a>, <a class="el" href="group__events.html#gacf7234ca254d2459a41bb6917b41ab60" title="Wait for an event, blocking indefinitely. ">WBWaitForEvent()</a></p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l08632">8632</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="ga7db44fa0c4785345f944167a066209d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7db44fa0c4785345f944167a066209d3">&#9670;&nbsp;</a></span>WBPostAppEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WBPostAppEvent </td>
          <td>(</td>
          <td class="paramtype">XEvent *&#160;</td>
          <td class="paramname"><em>pEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places a copy of the specified event at the end of the priority (internal) event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEvent</td><td>A pointer to an XEvent structure containing the event info </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-zero value on error, or zero if successful</dd></dl>
<p>The preferred method of event processing between windows is to post them to one of the internal event queues, rather than using XSendEvent or calling WBDispatch directly.<br />
Use WBPostAppEvent for application events (where the window ID is 'None')</p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l08671">8671</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="gae58733a08aa8a56986313c090d56fa9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae58733a08aa8a56986313c090d56fa9c">&#9670;&nbsp;</a></span>WBPostDelayedEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WBPostDelayedEvent </td>
          <td>(</td>
          <td class="paramtype">XEvent *&#160;</td>
          <td class="paramname"><em>pEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nDelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delays placing a copy of the specified event at the end of the regular (internal) event queue by a specified number of milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEvent</td><td>A pointer to an XEvent structure containing the event info </td></tr>
    <tr><td class="paramname">nDelay</td><td>The number of milliseconds to delay posting the event</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function to effectively delay an event's posting to the internal queue for a specified period of time, in milliseconds. For application messages, specify 'None' for the Window ID in the XEvent structure (otherwise specify the correct Window ID). After the time delay, the event will be retrieved and returned via <a class="el" href="group__events.html#gae65d3f6f49b844602dfc2ce6037fde09" title="Main message loop, high level API to check for and retrieve the next event. ">WBCheckGetEvent()</a>, or <a class="el" href="group__events.html#gaded67a2919c5cb862d512803fbcf21b5" title="low-level event queue wrapper. Implements the client-side event queue. Does not block if no events av...">WBNextEvent()</a>, similar to a timer message. If the window specified in the message is destroyed before the timeout, the message will be ignored.</p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l08650">8650</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="ga26c444fc559879a0457ad3915dc95041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26c444fc559879a0457ad3915dc95041">&#9670;&nbsp;</a></span>WBPostDelayedSetFocusAppEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WBPostDelayedSetFocusAppEvent </td>
          <td>(</td>
          <td class="paramtype">Display *&#160;</td>
          <td class="paramname"><em>pDisplay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Window&#160;</td>
          <td class="paramname"><em>wID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Window&#160;</td>
          <td class="paramname"><em>wIDFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nDelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 'set focus' ClientMessage event for the application event handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDisplay</td><td>The Display pointer, or 'None' to use default </td></tr>
    <tr><td class="paramname">wID</td><td>The Window ID of the window to be set active, raised, and mapped </td></tr>
    <tr><td class="paramname">wIDFrom</td><td>The previous window that was active, or None </td></tr>
    <tr><td class="paramname">nDelay</td><td>The delay in milliseconds before this action takes place (useful to prevent race conditions)</td></tr>
  </table>
  </dd>
</dl>
<p>Causes (reliable) 'Set Active' 'Set Input Focus' 'Raise Window' and 'Map Window' events to be applied to a particular window. In many cases window managers may differ in their handling of things like 'XSetFocus' to set focus to a window. By handling this in the application event queue, it is possible to delay events asynchronously in a manner that avoids a race condition from the window manager. Clicking on a window, or using ALT+Tab, or switching desktops may cause unexpected 'things' to take place. By forcing the window to be ACTIVE and also using the normal 'XSetInputFocus' function, as well as 'Raising' and mapping the window, THIS method is likely to work everywhere, and in a consistent manner.</p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l08684">8684</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="ga70cadee7dfde0a884dfdb5a36f4bf6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70cadee7dfde0a884dfdb5a36f4bf6b5">&#9670;&nbsp;</a></span>WBPostEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WBPostEvent </td>
          <td>(</td>
          <td class="paramtype">Window&#160;</td>
          <td class="paramname"><em>wID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XEvent *&#160;</td>
          <td class="paramname"><em>pEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places a copy of the specified event at the end of the regular (internal) event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wID</td><td>The Window ID of the event to be posted. The default 'Display *' will be used </td></tr>
    <tr><td class="paramname">pEvent</td><td>A pointer to an XEvent structure containing the event info </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-zero value on error, or zero if successful</dd></dl>
<p>The preferred method of event processing between windows is to post them to one of the internal event queues, rather than using XSendEvent() or calling <a class="el" href="group__events.html#ga79275e72d837cef2b535e9feeb81074f" title="Generic Event Dispatcher, using message type to dispatch. ">WBDispatch()</a> or <a class="el" href="group__events.html#gaf6df53fd27da18e4a5a0ad5077c45a21" title="Dispatches a window XEvent. May be called directly. ">WBWindowDispatch()</a> directly.<br />
You should always use this function for asynchronously posting non-priority events, such as notifications and timers, or when recursion may occur. Note that any pointers or X11 resources that are passed using XEvent may not be valid by the time they are received. If you must pass volatile data to a window, use <a class="el" href="group__events.html#ga79275e72d837cef2b535e9feeb81074f" title="Generic Event Dispatcher, using message type to dispatch. ">WBDispatch()</a> or <a class="el" href="group__events.html#gaf6df53fd27da18e4a5a0ad5077c45a21" title="Dispatches a window XEvent. May be called directly. ">WBWindowDispatch()</a> instead.</p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l08637">8637</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="gad1379e7531ae4e2b7f901b6e187623fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1379e7531ae4e2b7f901b6e187623fe">&#9670;&nbsp;</a></span>WBPostPriorityEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WBPostPriorityEvent </td>
          <td>(</td>
          <td class="paramtype">Window&#160;</td>
          <td class="paramname"><em>wID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XEvent *&#160;</td>
          <td class="paramname"><em>pEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places a copy of the specified event at the end of the priority (internal) event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wID</td><td>The Window ID of the event to be posted. The default 'Display *' will be used </td></tr>
    <tr><td class="paramname">pEvent</td><td>A pointer to an XEvent structure containing the event info </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-zero value on error, or zero if successful</dd></dl>
<p>The preferred method of event processing between windows is to post them to one of the internal event queues, rather than using XSendEvent() or calling <a class="el" href="group__events.html#ga79275e72d837cef2b535e9feeb81074f" title="Generic Event Dispatcher, using message type to dispatch. ">WBDispatch()</a> or <a class="el" href="group__events.html#gaf6df53fd27da18e4a5a0ad5077c45a21" title="Dispatches a window XEvent. May be called directly. ">WBWindowDispatch()</a> directly.<br />
Use WBPostPriorityEvent for priority events, such as UI handling (where performance is critical)</p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l08655">8655</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="gafa43907ec0a4d340d1741d95c573d8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa43907ec0a4d340d1741d95c573d8de">&#9670;&nbsp;</a></span>WBProcessExposeEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WBProcessExposeEvent </td>
          <td>(</td>
          <td class="paramtype">XExposeEvent *&#160;</td>
          <td class="paramname"><em>pEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level event processing, internal handling of Expose events </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEvent</td><td>A pointer to an XExposeEvent structure for an Expose event</td></tr>
  </table>
  </dd>
</dl>
<p>Instead of passing Expose events directly along to the respective window, they are first consolidated, and then re-prioritized for optimimum display performance.<br />
Expose events typically come in bunches, and all too frequently. By delaying their processing, AND consolidating them into a single event, it is possible to minimize the un-necessary re-drawing of windows and improve the 'apparent speed' of your applicatino. Normally this is done within <a class="el" href="group__events.html#gae65d3f6f49b844602dfc2ce6037fde09" title="Main message loop, high level API to check for and retrieve the next event. ">WBCheckGetEvent()</a> automatically. If you decide to implement the message prioritization yourself, you can use this function to handle Expose events for you, and correctly prioritize them.</p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l05426">5426</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="ga0c303659d95901643983f88a38948b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c303659d95901643983f88a38948b44">&#9670;&nbsp;</a></span>WBShowModal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WBShowModal </td>
          <td>(</td>
          <td class="paramtype">Window&#160;</td>
          <td class="paramname"><em>wID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bMenuSplashFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shows a 'modal' window by processing events until the window closes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wID</td><td>Window to be made modal </td></tr>
    <tr><td class="paramname">bMenuSplashFlag</td><td>Tri-state boolean indicating menu/splash/normal. A value of 0 is normal, &gt; 0 menu, &lt; 0 splash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error, or the dialog box's '<a class="el" href="group__events.html#gac1ece849fdeb1fc9c42f3565dcc35351" title="End a modal window with a specific return value. ">WBEndModal()</a>' iReturn value</dd></dl>
<p>Use this function to show a 'modal' window. The function returns when the window is closed. 'bMenuFlag' is &gt; 0 if menu semantics need to be applied to the modal window, or &lt; 0 if splash semantics need to be applied. Otherwise, it is treated as a NORMAL (dialog) window.</p>
<p>The return value is -1 on error, or the value specified by 'iReturn' in the call to <a class="el" href="group__events.html#gac1ece849fdeb1fc9c42f3565dcc35351" title="End a modal window with a specific return value. ">WBEndModal()</a>.</p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l01976">1976</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="gacf7234ca254d2459a41bb6917b41ab60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf7234ca254d2459a41bb6917b41ab60">&#9670;&nbsp;</a></span>WBWaitForEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WBWaitForEvent </td>
          <td>(</td>
          <td class="paramtype">Display *&#160;</td>
          <td class="paramname"><em>pDisplay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for an event, blocking indefinitely. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDisplay</td><td>a pointer to the Display on which to wait for events</td></tr>
  </table>
  </dd>
</dl>
<p>Call this function to wait until a new event is available in the event queue. This function will block indefinitely until such an event is available.<br />
NOTE: if 'bQuitFlag' is set, this function will return immediately.</p>
<p>See <a class="el" href="group__events.html#gaded67a2919c5cb862d512803fbcf21b5" title="low-level event queue wrapper. Implements the client-side event queue. Does not block if no events av...">WBNextEvent()</a>, <a class="el" href="group__events.html#gae65d3f6f49b844602dfc2ce6037fde09" title="Main message loop, high level API to check for and retrieve the next event. ">WBCheckGetEvent()</a></p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l03818">3818</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
<a id="gaf6df53fd27da18e4a5a0ad5077c45a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6df53fd27da18e4a5a0ad5077c45a21">&#9670;&nbsp;</a></span>WBWindowDispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WBWindowDispatch </td>
          <td>(</td>
          <td class="paramtype">Window&#160;</td>
          <td class="paramname"><em>wID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XEvent *&#160;</td>
          <td class="paramname"><em>pEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatches a window XEvent. May be called directly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wID</td><td>The Window ID that will be 'dispatched' the event, regardless of the event structure contents </td></tr>
    <tr><td class="paramname">pEvent</td><td>A pointer to an XEvent structure to process</td></tr>
  </table>
  </dd>
</dl>
<p>Dispatches an XEvent for the specified window. Normally, WBDispatch will call this function using the window ID from the XEvent itself, and pass that ID as the first parameter. A caller may choose to send the event to a different window, specifying its window ID instead. This is similar to a modal 'Event Send' and can be useful to have a parent or child widnow handle a particular type of event (rather than the destined window).</p>
<p>Header File: <a class="el" href="window__helper_8h.html" title="&#39;window helper&#39; main header file for the X11workbench Toolkit API ">window_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="window__helper_8c_source.html#l04788">4788</a> of file <a class="el" href="window__helper_8c_source.html">window_helper.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Sep 12 2017 16:42:00 for X11 Work Bench Toolkit by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>

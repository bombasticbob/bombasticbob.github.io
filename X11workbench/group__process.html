<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Copyright 2020 by S.F.T. Inc. and 'Bombastic' Bob Frazier in accordance with the X11workbench Project -->
<!--    Use and/or Distribution in accordance with either an MIT-like or LGPL v2 license - see COPYING     -->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>X11workbench Toolkit: Process Control Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxy_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">X11workbench Toolkit
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__process.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Process Control Functions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1bd64d7b39e976442d0b6a8f500c2353"><td class="memItemLeft" align="right" valign="top">WB_PROCESS_ID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process.html#ga1bd64d7b39e976442d0b6a8f500c2353">WBRunAsync</a> (const char *szAppName,...)</td></tr>
<tr class="memdesc:ga1bd64d7b39e976442d0b6a8f500c2353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run an application asynchronously.  <a href="#ga1bd64d7b39e976442d0b6a8f500c2353">More...</a><br /></td></tr>
<tr class="separator:ga1bd64d7b39e976442d0b6a8f500c2353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff7bb12c77e45ada78c88d916635c58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process.html#gaeff7bb12c77e45ada78c88d916635c58">WBGetProcessState</a> (WB_PROCESS_ID idProcess, <a class="el" href="group__platform__types.html#ga17e22d77ef26bafa95ceeffc51947c79">WB_INT32</a> *pExitCode)</td></tr>
<tr class="memdesc:gaeff7bb12c77e45ada78c88d916635c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check on a running process, and return its state, and optionally the exit code.  <a href="#gaeff7bb12c77e45ada78c88d916635c58">More...</a><br /></td></tr>
<tr class="separator:gaeff7bb12c77e45ada78c88d916635c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80b13461787c69ce1f94092abf3e983"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process.html#gaa80b13461787c69ce1f94092abf3e983">WBRunResult</a> (const char *szAppName,...)</td></tr>
<tr class="memdesc:gaa80b13461787c69ce1f94092abf3e983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run an application synchronously, returning 'stdout' output in a character buffer.  <a href="#gaa80b13461787c69ce1f94092abf3e983">More...</a><br /></td></tr>
<tr class="separator:gaa80b13461787c69ce1f94092abf3e983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69c221f2765a810ef29a5095fa3c4230"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process.html#ga69c221f2765a810ef29a5095fa3c4230">WBRunResultWithInput</a> (const char *szStdInBuf, const char *szAppName,...)</td></tr>
<tr class="memdesc:ga69c221f2765a810ef29a5095fa3c4230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run an application synchronously, supplying an input buffer for 'stdin', and returning 'stdout' output in a character buffer.  <a href="#ga69c221f2765a810ef29a5095fa3c4230">More...</a><br /></td></tr>
<tr class="separator:ga69c221f2765a810ef29a5095fa3c4230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b3e57d4acf34d5d353c646445d151c"><td class="memItemLeft" align="right" valign="top">WB_PROCESS_ID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process.html#ga87b3e57d4acf34d5d353c646445d151c">WBRunAsyncPipe</a> (WB_FILE_HANDLE hStdIn, WB_FILE_HANDLE hStdOut, WB_FILE_HANDLE hStdErr, const char *szAppName,...)</td></tr>
<tr class="memdesc:ga87b3e57d4acf34d5d353c646445d151c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run an application asynchronously, specifying file handles for STDIN, STDOUT, and STDERR.  <a href="#ga87b3e57d4acf34d5d353c646445d151c">More...</a><br /></td></tr>
<tr class="separator:ga87b3e57d4acf34d5d353c646445d151c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9c772c6392d057d17513176f3c65902"><td class="memItemLeft" align="right" valign="top">WB_PROCESS_ID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process.html#gaf9c772c6392d057d17513176f3c65902">WBRunAsyncPipeV</a> (WB_FILE_HANDLE hStdIn, WB_FILE_HANDLE hStdOut, WB_FILE_HANDLE hStdErr, const char *szAppName, va_list va)</td></tr>
<tr class="memdesc:gaf9c772c6392d057d17513176f3c65902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run an application asynchronously, specifying file handles for STDIN, STDOUT, and STDERR, using a va_list for the program's parameters.  <a href="#gaf9c772c6392d057d17513176f3c65902">More...</a><br /></td></tr>
<tr class="separator:gaf9c772c6392d057d17513176f3c65902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab174acc6a11dc722577cd5e3723f0b2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__types.html#ga7f0672ea4d50fd29e009c4945778a92a">WB_MODULE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process.html#gab174acc6a11dc722577cd5e3723f0b2d">WBLoadLibrary</a> (const char *szModuleName)</td></tr>
<tr class="memdesc:gab174acc6a11dc722577cd5e3723f0b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a shared library, DLL, module, or whatever you call it on your operating system.  <a href="#gab174acc6a11dc722577cd5e3723f0b2d">More...</a><br /></td></tr>
<tr class="separator:gab174acc6a11dc722577cd5e3723f0b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga560a982b02824d34447e2b581dc2e190"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process.html#ga560a982b02824d34447e2b581dc2e190">WBFreeLibrary</a> (<a class="el" href="group__platform__types.html#ga7f0672ea4d50fd29e009c4945778a92a">WB_MODULE</a> hModule)</td></tr>
<tr class="memdesc:ga560a982b02824d34447e2b581dc2e190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a shared library, DLL, module, or whatever, that was loaded via '<a class="el" href="group__process.html#gab174acc6a11dc722577cd5e3723f0b2d" title="Loads a shared library, DLL, module, or whatever you call it on your operating system.">WBLoadLibrary()</a>'.  <a href="#ga560a982b02824d34447e2b581dc2e190">More...</a><br /></td></tr>
<tr class="separator:ga560a982b02824d34447e2b581dc2e190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ebada7768666a227eddfbb7d49afc97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__types.html#gadec33de02b83d9f226bcb27b58f14366">WB_PROCADDRESS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process.html#ga3ebada7768666a227eddfbb7d49afc97">WBGetProcAddress</a> (<a class="el" href="group__platform__types.html#ga7f0672ea4d50fd29e009c4945778a92a">WB_MODULE</a> hModule, const char *szProcName)</td></tr>
<tr class="memdesc:ga3ebada7768666a227eddfbb7d49afc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a function pointer for an exported function symbol in a shared library (or DLL)  <a href="#ga3ebada7768666a227eddfbb7d49afc97">More...</a><br /></td></tr>
<tr class="separator:ga3ebada7768666a227eddfbb7d49afc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga782e2effd1492ba9b4b67be4b0adab65"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process.html#ga782e2effd1492ba9b4b67be4b0adab65">WBGetDataAddress</a> (<a class="el" href="group__platform__types.html#ga7f0672ea4d50fd29e009c4945778a92a">WB_MODULE</a> hModule, const char *szDataName)</td></tr>
<tr class="memdesc:ga782e2effd1492ba9b4b67be4b0adab65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a data pointer for an exported data symbol in a shared library (or DLL)  <a href="#ga782e2effd1492ba9b4b67be4b0adab65">More...</a><br /></td></tr>
<tr class="separator:ga782e2effd1492ba9b4b67be4b0adab65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This group consists of a set of functions that allow you to synchronously or asynchronously run processes, optionally re-directing input and output to or from a file or memory buffer. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga560a982b02824d34447e2b581dc2e190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga560a982b02824d34447e2b581dc2e190">&#9670;&nbsp;</a></span>WBFreeLibrary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WBFreeLibrary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__platform__types.html#ga7f0672ea4d50fd29e009c4945778a92a">WB_MODULE</a>&#160;</td>
          <td class="paramname"><em>hModule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a shared library, DLL, module, or whatever, that was loaded via '<a class="el" href="group__process.html#gab174acc6a11dc722577cd5e3723f0b2d" title="Loads a shared library, DLL, module, or whatever you call it on your operating system.">WBLoadLibrary()</a>'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hModule</td><td>A valid WB_MODULE module handle, as returned by <a class="el" href="group__process.html#gab174acc6a11dc722577cd5e3723f0b2d" title="Loads a shared library, DLL, module, or whatever you call it on your operating system.">WBLoadLibrary()</a></td></tr>
  </table>
  </dd>
</dl>
<p>This function is identical to FreeLibrary() under Windows, and is a wrapper for 'dlfree()' on POSIX systems.</p>
<p>Use this to free a shared library (or DLL) that was opened with <a class="el" href="group__process.html#gab174acc6a11dc722577cd5e3723f0b2d" title="Loads a shared library, DLL, module, or whatever you call it on your operating system.">WBLoadLibrary()</a>.</p>
<p>In POSIX systems, the 'dlfree' function will invoke '_fini()' within the shared library, if it is present, the when the library is finally unmapped from the address space. In Windows, the FreeLibrary() function calls 'DllMain()' within the DLL, with one of various parameters, typically DLL_PROCESS_DETACH. The semantics are much more complicated for Windows (see MSDN documentation for 'DllMain()')</p>
<p>Certain library and API functions may not be available in '_fini()' or 'DllMain()' - see appropriate documentation for any restrictions that might apply to your shared libraries (DLLs).</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions.">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l04597">4597</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga782e2effd1492ba9b4b67be4b0adab65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga782e2effd1492ba9b4b67be4b0adab65">&#9670;&nbsp;</a></span>WBGetDataAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* WBGetDataAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__platform__types.html#ga7f0672ea4d50fd29e009c4945778a92a">WB_MODULE</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szDataName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a data pointer for an exported data symbol in a shared library (or DLL) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hModule</td><td>A valid WB_MODULE module handle, as returned by <a class="el" href="group__process.html#gab174acc6a11dc722577cd5e3723f0b2d" title="Loads a shared library, DLL, module, or whatever you call it on your operating system.">WBLoadLibrary()</a> </td></tr>
    <tr><td class="paramname">szDataName</td><td>A const pointer to a character string containing the data name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the data item, or NULL if the symbol does not exist.</dd></dl>
<p>This function is identical to GetProcAddress() under Windows, with the return data type cast to 'void *'. It is a wrapper for 'dlsym()' on POSIX systems.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions.">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l04612">4612</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga3ebada7768666a227eddfbb7d49afc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ebada7768666a227eddfbb7d49afc97">&#9670;&nbsp;</a></span>WBGetProcAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__types.html#gadec33de02b83d9f226bcb27b58f14366">WB_PROCADDRESS</a> WBGetProcAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__platform__types.html#ga7f0672ea4d50fd29e009c4945778a92a">WB_MODULE</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szProcName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a function pointer for an exported function symbol in a shared library (or DLL) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hModule</td><td>A valid WB_MODULE module handle, as returned by <a class="el" href="group__process.html#gab174acc6a11dc722577cd5e3723f0b2d" title="Loads a shared library, DLL, module, or whatever you call it on your operating system.">WBLoadLibrary()</a> </td></tr>
    <tr><td class="paramname">szProcName</td><td>A const pointer to a character string containing the proc name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A function pointer as a 'WB_PROCADDRESS' type, or NULL if the symbol does not exist</dd></dl>
<p>This function is identical to GetProcAddress() under Windows, and is a wrapper for 'dlfunc()' or 'dlsym()' on POSIX systems</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions.">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l04602">4602</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gaeff7bb12c77e45ada78c88d916635c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeff7bb12c77e45ada78c88d916635c58">&#9670;&nbsp;</a></span>WBGetProcessState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WBGetProcessState </td>
          <td>(</td>
          <td class="paramtype">WB_PROCESS_ID&#160;</td>
          <td class="paramname"><em>idProcess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__types.html#ga17e22d77ef26bafa95ceeffc51947c79">WB_INT32</a> *&#160;</td>
          <td class="paramname"><em>pExitCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check on a running process, and return its state, and optionally the exit code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idProcess</td><td>A WB_PROCESS_ID for the running process </td></tr>
    <tr><td class="paramname">pExitCode</td><td>An optional pointer to a WB_INT32 to retrieve the exit code (may be NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive value if the process is still running, zero if the process has terminated, negative on error.</dd></dl>
<p>Call this function to determine if an asynchronous process is still running, and possibly retrieve the exit code if it is no longer running. On POSIX systems, the exit code is generally a single byte (other values may be reserved). On Windows, it's officially an unsigned 32-bit integer.</p>
<p>If a process is suspended, killed, or exits due to a system error, this function will not differentiate between normal or abnormal termination, or between running or suspended. If you need this kind of complex application status, use 'waitpid()' (POSIX) or GetExitCodeProcess() (Windows).</p>
<p>This function does not perform any explicit wait states when checking a process's state. If you must block your thread's execution in order to wait for a process to exit, you should call WBSleep() (or its equivalent) within the loop to avoid 'maxing out' the CPU utilization, which would very likely use up more electricity than a more efficient wait state.</p>
<p>See Also: <a class="el" href="group__process.html#ga1bd64d7b39e976442d0b6a8f500c2353" title="Run an application asynchronously.">WBRunAsync()</a>, <a class="el" href="group__process.html#ga87b3e57d4acf34d5d353c646445d151c" title="Run an application asynchronously, specifying file handles for STDIN, STDOUT, and STDERR.">WBRunAsyncPipe()</a>, <a class="el" href="group__process.html#gaf9c772c6392d057d17513176f3c65902" title="Run an application asynchronously, specifying file handles for STDIN, STDOUT, and STDERR,...">WBRunAsyncPipeV()</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l04392">4392</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gab174acc6a11dc722577cd5e3723f0b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab174acc6a11dc722577cd5e3723f0b2d">&#9670;&nbsp;</a></span>WBLoadLibrary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__types.html#ga7f0672ea4d50fd29e009c4945778a92a">WB_MODULE</a> WBLoadLibrary </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szModuleName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a shared library, DLL, module, or whatever you call it on your operating system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szModuleName</td><td>A const pointer to a character string containing the path for the library, module, DLL, or whatever </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid WB_MODULE module handle, depending upon the operating system</dd></dl>
<p>This function is identical to LoadLibrary() under Windows, and is a wrapper for 'dlopen()' on POSIX systems.</p>
<p>Use this to dynamically load a shared library (or DLL under Windows) at run-time from within your application.</p>
<p>In POSIX systems, the 'dlopen' function will invoke '_init()' within the shared library, if it is present, the first time the library is mapped into the address space. In Windows, the LoadLibrary() function calls 'DllMain()' within the DLL, with one of various parameters, typically DLL_PROCESS_ATTACH. The semantics are much more complicated for Windows (see MSDN documentation for 'DllMain()')</p>
<p>Additionally, for POSIX systems, the 'dlopen()' function is called with access set to (RTLD_LAZY | RTLD_LOCAL). This implies that a) each external reference is resolved when you call the appropriate function; and b) Only symbols defined in the library and it's "DAG" of needed objects will be resolvable [default behavior]. If you want a different behavior, you can call 'dlopen()' yourself, and cast the return value to a WB_MODULE.</p>
<p>Certain library and API functions may not be available in '_init()' or 'DllMain()' - see appropriate documentation for any restrictions that might apply to your shared libraries (DLLs).</p>
<p>See also: <a class="el" href="group__process.html#ga3ebada7768666a227eddfbb7d49afc97" title="Obtains a function pointer for an exported function symbol in a shared library (or DLL)">WBGetProcAddress()</a>, <a class="el" href="group__process.html#ga560a982b02824d34447e2b581dc2e190" title="Frees a shared library, DLL, module, or whatever, that was loaded via &#39;WBLoadLibrary()&#39;.">WBFreeLibrary()</a></p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions.">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l04592">4592</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga1bd64d7b39e976442d0b6a8f500c2353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bd64d7b39e976442d0b6a8f500c2353">&#9670;&nbsp;</a></span>WBRunAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WB_PROCESS_ID WBRunAsync </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szAppName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run an application asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szAppName</td><td>A const pointer to a character string containing the path to the application </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid process ID or process handle, depending upon the operating system. On error it returns WB_INVALID_FILE_HANDLE</dd></dl>
<p>Use this function to spawn an asynchronous process. The function returns an invalid process ID or process handle on error. If the process ID is an allocated resource, the caller must free it. Each additional parameter passed to this function is a parameter that is to be passed to the program. The final parameter in the list must be NULL, so any call to this function will need to have at least 2 parameters.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions.">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l04177">4177</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga87b3e57d4acf34d5d353c646445d151c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87b3e57d4acf34d5d353c646445d151c">&#9670;&nbsp;</a></span>WBRunAsyncPipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WB_PROCESS_ID WBRunAsyncPipe </td>
          <td>(</td>
          <td class="paramtype">WB_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hStdIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WB_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hStdOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WB_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hStdErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szAppName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run an application asynchronously, specifying file handles for STDIN, STDOUT, and STDERR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStdIn</td><td>A WB_FILE_HANDLE for STDIN, or WB_INVALID_FILE_HANDLE </td></tr>
    <tr><td class="paramname">hStdOut</td><td>A WB_FILE_HANDLE for STDOUT, or WB_INVALID_FILE_HANDLE </td></tr>
    <tr><td class="paramname">hStdErr</td><td>A WB_FILE_HANDLE for STDERR, or WB_INVALID_FILE_HANDLE. This can be the same handle as hStdErr, though interleaved output may not occur as expected. </td></tr>
    <tr><td class="paramname">szAppName</td><td>A const pointer to a character string containing the path to the application </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid process ID or process handle, depending upon the operating system. On error, it returns WB_INVALID_FILE_HANDLE</dd></dl>
<p>Use this function to spawn an asynchronous process in which you want to track STDIN, STDOUT, and/or STDERR. The function returns an invalid process ID or process handle on error. If the process ID is an allocated resource, the caller must free it. Each additional parameter passed to this function will become a parameter that is to be passed to the program. The final parameter in the list must be NULL to mark the end of the list, so any call to this function will need to have at least 5 parameters.<br />
<br />
If you do not want to re-direct a file handle, pass 'WB_INVALID_FILE_HANDLE' for its value. It is also possible to pass the SAME file handle for hStdIn, hStdOut, and hStdErr provided that it has the correct read/write access available. File handles passed to this function will be duplicated, but not closed. It is safe (and prudent) to close the original file handles immediately after calling this function.<br />
<br />
You can monitor 'WB_PROCESS_ID' to find out if the process is running. Additionally, you can use the output of hStdOut and hStdErr by re-directing them to anonymous pipes and monitoring their activity.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions.">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l04201">4201</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gaf9c772c6392d057d17513176f3c65902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9c772c6392d057d17513176f3c65902">&#9670;&nbsp;</a></span>WBRunAsyncPipeV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WB_PROCESS_ID WBRunAsyncPipeV </td>
          <td>(</td>
          <td class="paramtype">WB_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hStdIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WB_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hStdOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WB_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hStdErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szAppName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>va</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run an application asynchronously, specifying file handles for STDIN, STDOUT, and STDERR, using a va_list for the program's parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStdIn</td><td>A WB_FILE_HANDLE for STDIN, or WB_INVALID_FILE_HANDLE </td></tr>
    <tr><td class="paramname">hStdOut</td><td>A WB_FILE_HANDLE for STDOUT, or WB_INVALID_FILE_HANDLE </td></tr>
    <tr><td class="paramname">hStdErr</td><td>A WB_FILE_HANDLE for STDERR, or WB_INVALID_FILE_HANDLE. This can be the same handle as hStdErr, though interleaved output may not occur as expected. </td></tr>
    <tr><td class="paramname">szAppName</td><td>A const pointer to a character string containing the path to the application </td></tr>
    <tr><td class="paramname">va</td><td>A va_list of the arguments (the final one must be NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid process ID or process handle, depending upon the operating system. On error, it returns WB_INVALID_FILE_HANDLE</dd></dl>
<p>This function is identical to <a class="el" href="group__process.html#ga87b3e57d4acf34d5d353c646445d151c" title="Run an application asynchronously, specifying file handles for STDIN, STDOUT, and STDERR.">WBRunAsyncPipe()</a> except that the variable argument list is passed as a va_list.<br />
Use this function to spawn an asynchronous process in which you want to track STDIN, STDOUT, and/or STDERR. The function returns an invalid process ID or process handle on error. If the process ID is an allocated resource, the caller must free it. Parameters passed to this function as part of the va_list are parameters that are to be passed to the program. The final parameter in the va_list must be NULL to mark the end of the list.<br />
If you do not want to re-direct a file handle, pass 'WB_INVALID_FILE_HANDLE' for its value. It is also possible to pass the SAME file handle for hStdIn, hStdOut, and hStdErr provided that it has the correct read/write access available. File handles passed to this function will be duplicated, but not closed. It is also safe to close the original file handles immediately after calling this function.<br />
You can monitor 'WB_PROCESS_ID' to find out if the process is running. Additionally, you can use the output of hStdOut and hStdErr by re-directing them to anonymous pipes and monitoring their activity.</p>
<p>This function is used internally by the other process control functions, and is defined here in case you need to write a customized version of one of the process control functions. A typical example might be the use of stderr rather than stdout for <a class="el" href="group__process.html#gaa80b13461787c69ce1f94092abf3e983" title="Run an application synchronously, returning &#39;stdout&#39; output in a character buffer.">WBRunResult()</a>.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions.">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l03701">3701</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="gaa80b13461787c69ce1f94092abf3e983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa80b13461787c69ce1f94092abf3e983">&#9670;&nbsp;</a></span>WBRunResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* WBRunResult </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szAppName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run an application synchronously, returning 'stdout' output in a character buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szAppName</td><td>A const pointer to a character string containing the path to the application </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="group__sub__alloc.html#ga8ee962cea8e2f0cb52d1cab9057ffe6c" title="High performance memory sub-allocator &#39;allocate&#39;.">WBAlloc()</a> pointer to a buffer containing the 'stdout' output from the application, or NULL on error.</dd></dl>
<p>Use this function to run an external process and capture its output. This function will ignore the error return code from the program, so if this information is necessary, you should write a different function (based on this one) using 'WBRunAsync' and a wait loop, etc. that checks the application's return value on exit. Each additional parameter passed to this function is a parameter that is to be passed to the program. The final parameter in the list must be NULL, so any call to this function will need to have at least 2 parameters. On error this function returns a NULL value. Any non-NULL value must be 'free'd by the caller using <a class="el" href="group__sub__alloc.html#gaebf9d7c0cd9aa525a93d0c5cc5376a1c" title="High performance memory sub-allocator &#39;free&#39;.">WBFree()</a>.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions.">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l04446">4446</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
<a id="ga69c221f2765a810ef29a5095fa3c4230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69c221f2765a810ef29a5095fa3c4230">&#9670;&nbsp;</a></span>WBRunResultWithInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* WBRunResultWithInput </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szStdInBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szAppName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run an application synchronously, supplying an input buffer for 'stdin', and returning 'stdout' output in a character buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szStdInBuf</td><td>A const pointer to 0-byte terminated string/buffer containing the input for piped data. </td></tr>
    <tr><td class="paramname">szAppName</td><td>A const pointer to a character string containing the path to the application </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="group__sub__alloc.html#ga8ee962cea8e2f0cb52d1cab9057ffe6c" title="High performance memory sub-allocator &#39;allocate&#39;.">WBAlloc()</a> pointer to a buffer containing the 'stdout' output from the application.</dd></dl>
<p>Use this function to run an external process, providing a buffer that contains data to be sent to the applications 'stdin', and in the process, capture its output. This function will ignore the error return code from the program, so if this information is necessary, you should write a different function (based on this one) using 'WBRunAsync' and a wait loop, etc. that checks the application's return value on exit.</p>
<p>Each additional parameter passed to this function is a parameter that is to be passed to the program. The final parameter in the list must be NULL, so any call to this function will need to have at least 3 parameters.</p>
<p>On error this function returns a NULL value. Any non-NULL value must be 'free'd by the caller using <a class="el" href="group__sub__alloc.html#gaebf9d7c0cd9aa525a93d0c5cc5376a1c" title="High performance memory sub-allocator &#39;free&#39;.">WBFree()</a>.<br />
 To create simple piped output, pass the result of the previous 'WBRunResult' or '<a class="el" href="group__process.html#ga69c221f2765a810ef29a5095fa3c4230" title="Run an application synchronously, supplying an input buffer for &#39;stdin&#39;, and returning &#39;stdout&#39; outpu...">WBRunResultWithInput()</a>' as the 'szStdInBuf' parameter to a subsequent '<a class="el" href="group__process.html#ga69c221f2765a810ef29a5095fa3c4230" title="Run an application synchronously, supplying an input buffer for &#39;stdin&#39;, and returning &#39;stdout&#39; outpu...">WBRunResultWithInput()</a>' call.</p>
<p>Header File: <a class="el" href="platform__helper_8h.html" title="Definition file for platform-specific utility functions.">platform_helper.h</a> </p>

<p class="definition">Definition at line <a class="el" href="platform__helper_8c_source.html#l04463">4463</a> of file <a class="el" href="platform__helper_8c_source.html">platform_helper.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Jan 26 2020 15:41:03 for X11workbench Toolkit by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
<!-- Copyright 2020 by S.F.T. Inc. and 'Bombastic' Bob Frazier in accordance with the X11workbench Project -->
<!--    Use and/or Distribution in accordance with either an MIT-like or LGPL v2 license - see COPYING     -->
</html>
